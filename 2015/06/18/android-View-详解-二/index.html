<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>android View 详解(二) | 季高</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="hljs.initHighlightingOnLoad();
 $(document).ready(function(){      $(“h2,h3,h4,h5,h6”).each(function(i,item){        var tag = $(item).get(0).localName;        $(item).attr(“id”,”wow”+i);        $(“#c">
<meta property="og:type" content="article">
<meta property="og:title" content="android View 详解(二)">
<meta property="og:url" content="http://canglangwenyue.com/2015/06/18/android-View-详解-二/index.html">
<meta property="og:site_name" content="季高">
<meta property="og:description" content="hljs.initHighlightingOnLoad();
 $(document).ready(function(){      $(“h2,h3,h4,h5,h6”).each(function(i,item){        var tag = $(item).get(0).localName;        $(item).attr(“id”,”wow”+i);        $(“#c">
<meta property="og:image" content="http://cl.ly/image/1x0V2j0E1D0G/%E6%9E%B6%E6%9E%84%E5%9B%BE.png">
<meta property="og:image" content="http://cdn1.snapgram.co/imgs/2015/06/19/android.png">
<meta property="og:image" content="http://cdn1.snapgram.co/imgs/2015/06/19/activityView.jpg">
<meta property="og:image" content="http://cdn1.snapgram.co/imgs/2015/06/20/View.png">
<meta property="og:image" content="http://cdn2.snapgram.co/imgs/2015/06/20/Viewmeasure.png">
<meta property="og:image" content="http://cdn2.snapgram.co/imgs/2015/06/20/ViewLayout.png">
<meta property="og:image" content="http://cdn1.snapgram.co/imgs/2015/06/20/ViewDraw.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="android View 详解(二)">
<meta name="twitter:description" content="hljs.initHighlightingOnLoad();
 $(document).ready(function(){      $(“h2,h3,h4,h5,h6”).each(function(i,item){        var tag = $(item).get(0).localName;        $(item).attr(“id”,”wow”+i);        $(“#c">
  
    <link rel="alternative" href="/atom.xml" title="季高" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">季高</a></h1>
		</hgroup>

		
		<p class="header-subtitle">他年我若为青帝，抱死桃花一处开!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>Тэги</li>
						
						<li>友情链接</li>
						
						
						<li>О сайте</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Reading/" style="font-size: 10px;">Reading</a><a href="/tags/android/" style="font-size: 20px;">android</a><a href="/tags/java/" style="font-size: 10px;">java</a><a href="/tags/点滴/" style="font-size: 15px;">点滴</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">季高</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">季高</h1>
			</hgroup>
			
			<p class="header-subtitle">他年我若为青帝，抱死桃花一处开!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-android-View-详解-二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/18/android-View-详解-二/" class="article-date">
  	<time datetime="2015-06-18T07:19:56.000Z" itemprop="datePublished">2015-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      android View 详解(二)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" href="http://yandex.st/highlightjs/6.2/styles/googlecode.min.css">

<script src="http://code.jquery.com/jquery-1.7.2.min.js"></script>
<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>

<p><script>hljs.initHighlightingOnLoad();</script></p>
<p><script type="text/javascript"><br> $(document).ready(function(){<br>      $(“h2,h3,h4,h5,h6”).each(function(i,item){<br>        var tag = $(item).get(0).localName;<br>        $(item).attr(“id”,”wow”+i);<br>        $(“#category”).append(‘<a class="new'+tag+'" href="#wow'+i+'">‘+$(this).text()+’</a></br>‘);<br>        $(“.newh2”).css(“margin-left”,0);<br>        $(“.newh3”).css(“margin-left”,20);<br>        $(“.newh4”).css(“margin-left”,40);<br>        $(“.newh5”).css(“margin-left”,60);<br>        $(“.newh6”).css(“margin-left”,80);<br>      });<br> });<br></script></p>
<div id="category"></div>

<h2 id="How_android_draw_Views">How android draw Views</h2><p>首先，看一下开发文档<a href="https://developer.android.com/guide/topics/ui/how-android-draws.html" target="_blank" rel="external">how android draw views</a>这个文档讲的比较空泛，先读一下，有个简单的了解.简单翻译一下。</p>
<p>   When an Activity receives focus, it will be requested to draw its layout. The Android framework will handle the procedure for drawing, but <strong>the Activity must provide the root node</strong> of its layout hierarchy.<br><a id="more"></a></p>
<p>   Drawing begins with the root node of the layout. It is requested to measure and    draw the layout tree. Drawing is handled by walking the tree and rendering each View that intersects the invalid region. In turn, each ViewGroup is responsible for requesting each of its children to be drawn (with the draw() method) and each View is responsible for drawing itself. Because the tree is traversed in-order, this means that parents will be drawn before (i.e., behind) their children, with siblings drawn in the order they appear in the tree.</p>
<p>   绘制从布局的root node开始，需要测量和绘制layout tree。绘制是通过遍历树，并且呈现出每个View相交的无效区域。反过来，每个ViewGroup负责它的每个孩子的绘制，每个View负责绘制它本身。因为树是先序遍历的，所以parents必须在它们的children之前被绘制，与它们在树中出现的相同顺序绘制兄弟node。</p>
<p>   <em>Note:</em></p>
<p>   The framework will not draw View objects that are not in the invalid region, and also will take care of drawing the View background for you.</p>
<pre><code>You can force <span class="tag">a</span> View to draw, by calling <span class="function"><span class="title">invalidate</span><span class="params">()</span></span>.
</code></pre><p>   Drawing the layout is a two pass process: <strong>a measure pass and a layout pass</strong>. The measuring pass is implemented in measure(int, int) and is a top-down traversal of the View tree. Each View pushes dimension specifications down the tree during the recursion. At the end of the measure pass, every View has stored its measurements. The second pass happens in layout(int, int, int, int) and is also top-down. During this pass each parent is responsible for positioning all of its children using the sizes computed in the measure pass.</p>
<p>   有两个passa measure pass and a layout pass(自顶向下遍历树)。Measure结束时每个View存储了自己的尺寸；之后layout pass开始执行：每个parents用来自measure pass的数据来布局自己的children在自身中的位置。</p>
<p>   When a View object’s measure() method returns, its getMeasuredWidth() and getMeasuredHeight() values must be set, along with those for all of that View object’s descendants. A View object’s measured width and measured height values must respect the constraints imposed by the View object’s parents. This guarantees that at the end of the measure pass, all parents accept all of their children’s measurements. A parent View may call measure() more than once on its children. For example, the parent may measure each child once with unspecified dimensions to find out how big they want to be, then call measure() on them again with actual numbers if the sum of all the children’s unconstrained sizes is too big or too small (that is, if the children don’t agree among themselves as to how much space they each get, the parent will intervene and set the rules on the second pass).</p>
<p>   当一个View对象的measure()方法执行结束时，这个View以及它的后代的getMeasuredWidth() and getMeasuredHeight() values must be set。并且一个View对象的测量得到的width和height必须遵循该View的parent的限制。这保证了在测量阶段结束时，所有的父母接受所有子女的尺寸。</p>
<p>   <em>Note:</em></p>
<p>   To initiate a layout, call requestLayout(). This method is typically called by a View on itself when it believes that is can no longer fit within its current bounds.</p>
<h3 id="View_Measure过程">View Measure过程</h3><p>   The measure pass uses two classes to communicate dimensions. The ViewGroup.LayoutParams class is used by View objects to tell their parents how they want to be measured and positioned. The base ViewGroup.LayoutParams class just describes how big the View wants to be for both width and height. For each dimension, it can specify one of:</p>
<p>   measure pass通过两个classes来表达尺寸。</p>
<h4 id="ViewGroup-LayoutParams">ViewGroup.LayoutParams</h4><p>   ViewGroup.LayoutParams负责描述被绘制View的width和height，它的值时下方中的一种：</p>
<ul>
<li><p>an exact number</p>
</li>
<li><p>MATCH_PARENT, which means the View wants to be as big as its parent (minus padding)</p>
</li>
<li><p>WRAP_CONTENT, which means that the View wants to be just big enough to enclose its content (plus padding).</p>
<p>针对ViewGroup的不同子类实现了ViewGroup.LayoutParams的子类。</p>
</li>
</ul>
<h4 id="MeasureSpec">MeasureSpec</h4><p>   MeasureSpec对象用于推动自顶向下绘制View的需求。一个MeasureSpec可以在三种模式中的一种：</p>
<ul>
<li><p>UNSPECIFIED: This is used by a parent to determine the desired dimension of a child View. For example, a LinearLayout may call measure() on its child with the height set to UNSPECIFIED and a width of EXACTLY 240 to find out how tall the child View wants to be given a width of 240 pixels.</p>
</li>
<li><p>EXACTLY: This is used by the parent to impose an exact size on the child. The child must use this size, and guarantee that all of its descendants will fit within this size.</p>
</li>
<li><p>AT MOST: This is used by the parent to impose a maximum size on the child. The child must guarantee that it and all of its descendants will fit within this size.</p>
</li>
</ul>
<p>好了，如果你的目的是简单的了解View的绘制过程，那么你的目的已经达到了。</p>
<h2 id="View_绘制流程深入">View 绘制流程深入</h2><p>参考，<strong>《android 内核剖析》 柯元旦</strong>向大牛致敬!!!</p>
<h3 id="准备知识">准备知识</h3><h4 id="首先，需要明确一些androidUI相关的一些概念">首先，需要明确一些androidUI相关的一些概念</h4><ul>
<li>Activity：Activity包含一个Window，该Window在Activity的attach方法中通过调用PolicyManager.makeNewWindo创建；</li>
<li>View：最基本的UI组件，表示屏幕上的一个矩形区域；</li>
<li>DecorView：是Window中View的RootView，设置窗口属性；</li>
<li>Window：表示顶层窗口，管理界面的显示和事件的响应；每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口</li>
<li>WindowManager：一个interface，继承自ViewManager。所在应用进程的窗口管理器；有一个implementation WindowManagerImpl；主要用来管理窗口的一些状态、属性、view增加、删除、更新、窗口顺序、消息收集和处理等。</li>
<li>ViewRoot：通过IWindowSession接口与全局窗口管理器进行交互：界面控制和消息响应；</li>
<li><p>ActivityThread：应用程序的主线程，其中会创建关联当前Activity与Window；创建WIndowManager实现类实例，把当前DecoView加入到WindowManager；</p>
<p>android UI架构图如下：<br><img src="http://cl.ly/image/1x0V2j0E1D0G/%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""><br>View绘制流程的函数调用链如下：<br><img src="http://cdn1.snapgram.co/imgs/2015/06/19/android.png" alt=""><br>图片来源 <a href="https://plus.google.com/+ArpitMathur/posts/cT1EuBbxEgN" target="_blank" rel="external">https://plus.google.com/+ArpitMathur/posts/cT1EuBbxEgN</a></p>
</li>
</ul>
<p>假设，我们有两个Activity，分别是ActivityA通过startActivity()来加载ActivityB让我们先来回顾一下，这个加载过程：<br><img src="http://cdn1.snapgram.co/imgs/2015/06/19/activityView.jpg" alt=""></p>
<h4 id="MeasureSpec类">MeasureSpec类</h4><p>   因为在View加载过程中需要它来传递一些信息，所以先来看一下这个类。MeasureSpec是View的一个静态内部类。主要职能是<strong>将父View的layout requirement 传递给子View</strong> Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode. There are three possible modes:</p>
<ul>
<li><p>UNSPECIFIED</p>
<p>The parent has not imposed any constraint on the child. It can be whatever size it wants.</p>
</li>
<li><p>EXACTLY<br>The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be.</p>
</li>
<li><p>AT_MOST</p>
<p>The child can be as large as it wants up to the specified size.</p>
</li>
</ul>
<p>以及，接下来要用到的三个method</p>
<ul>
<li><p>getMode(int measureSpec)</p>
<p>Extracts the mode from the supplied measure specification.获取mode</p>
</li>
<li><p>getSize(int measureSpec)</p>
<p>Extracts the size from the supplied measure specification.获取size(width/height)</p>
</li>
<li><p>makeMeasureSpec(int size, int mode)</p>
<p>Creates a measure specification based on the supplied size and mode.(封装一个MeasureSpec对象)</p>
</li>
</ul>
<p>接下来，我们来从源码的角度分析Measure过程</p>
<h4 id="View绘制整体流程梳理">View绘制整体流程梳理</h4><p>首先需要明确一点，android UI框架绘制View是从ViewRootImpl.java类开始的。</p>
<p><em>Note:</em>ViewRoot自2.3.7版本之后就被ViewRootImpl类取代了。</p>
<p>View树的绘制是从ViewRootImpl类的private void performTraversals()方法开始的。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始View绘制流程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> performTraversals()&#123;</span><br><span class="line">       <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">       <span class="keyword">final</span> View host = mView;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这两个值是由MeasureSpec.makeMeasureSpec()构建的。</span></span><br><span class="line">       <span class="built_in">int</span> desiredWindowWidth;  </span><br><span class="line">       <span class="built_in">int</span> desiredWindowHeight;</span><br><span class="line">         </span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">       <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">           ...                        </span><br><span class="line">	<span class="comment">//最外层的根视图的widthMeasureSpec和heightMeasureSpec由来</span></span><br><span class="line">	<span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于MATCH_PARENT</span></span><br><span class="line">       <span class="built_in">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.<span class="variable">width</span>);</span><br><span class="line">       <span class="built_in">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.<span class="variable">height</span>);</span><br><span class="line">   </span><br><span class="line">       ...</span><br><span class="line">       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">   </span><br><span class="line">   	...</span><br><span class="line">   </span><br><span class="line">       performLayout(); </span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">        mView.<span class="title">draw</span>(canvas);</span><br><span class="line">       <span class="comment">//performTraversals()方法负责了View绘制的三个流程，其他细节代码省略</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>performMeasure源码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//因为View的measure方法是public final，所以此处调用View的measure()方法</span></span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure></p>
<p>performLayout源码</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void performLayout<span class="literal">()</span> &#123;</span><br><span class="line">        mLayoutRequested = <span class="literal">false</span>;</span><br><span class="line">        mScrollMayChange = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     	...</span><br><span class="line">     	</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        此处调用<span class="type">View</span>的layout<span class="literal">()</span>方法</span><br><span class="line">            host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth<span class="literal">()</span>, host.getMeasuredHeight<span class="literal">()</span>);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="type">Trace</span>.traceEnd(<span class="type">Trace</span>.<span class="type">TRACE_TAG_VIEW</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>getRootMeasureSpec()源码</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> measureSpec;</span><br><span class="line">     <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">//RootView强制走MATCH_PARENT <span class="keyword">case</span>,这就是为何RootView总是全屏</span><br><span class="line">         // Window can't resize. Force root view to be windowSize.</span><br><span class="line">         measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">         // Window can resize. Set max size <span class="keyword">for</span> root view.</span><br><span class="line">         measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         // Window wants to be an exact size. Force root view to be that size.</span><br><span class="line">         measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> measureSpec;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里并不需要多说什么。看一下流程图。对于这部分的理解可以参照LayoutInflater加载XML文件的机制，二者的整体思路是一致的。</p>
<p><img src="http://cdn1.snapgram.co/imgs/2015/06/20/View.png" alt=""></p>
<h3 id="Measure过程">Measure过程</h3><h4 id="调用View-measure()方法进行预处理">调用View.measure()方法进行预处理</h4><p>   因为measure()方法是final修饰，所以View的所有子类都不能重载该方法。所以View子类只能通过重载onMeasure来实现自己的测量逻辑。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否为强制布局，即带有“FORCE_LAYOUT”标记 以及 widthMeasureSpec或heightMeasureSpec发生了改变 </span></span><br><span class="line">      <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">              widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">              heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">	<span class="comment">//清除MEASURED_DIMENSION_SET标记   ，该标记会在onMeasure()方法后被设置  </span></span><br><span class="line">          mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">          resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">	  <span class="comment">// 1、 测量该View本身的大小 ； 2 、 设置MEASURED_DIMENSION_SET标记，否则接写来会报异常</span></span><br><span class="line">          onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">          <span class="comment">// an exception to warn the developer</span></span><br><span class="line">          <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onMeasure() did not set the"</span></span><br><span class="line">                      + <span class="string">" measured dimension by calling"</span></span><br><span class="line">                      + <span class="string">" setMeasuredDimension()"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//下一步是layout了，添加LAYOUT_REQUIRED标记  </span></span><br><span class="line">          mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数widthMeasureSpec和heightMeasureSpec 由父View构建，表示父View给子View的测量要求</span></span><br><span class="line">      mOldWidthMeasureSpec = widthMeasureSpec;<span class="comment">//保存值,下次递归时会作为旧值进行比较</span></span><br><span class="line">      mOldHeightMeasureSpec = heightMeasureSpec;<span class="comment">//保存值</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>   其中onMeasure(widthMeasureSpec, heightMeasureSpec)的参数widthMeasureSpec和heightMeasureSpec 由父View构建，表示父View给子View的测量要求。</p>
<h4 id="回调View-onMeasure()方法设置View的Width和Height">回调View.onMeasure()方法设置View的Width和Height</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void <span class="function">onMeasure</span>(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        <span class="function">setMeasuredDimension</span>(<span class="function">getDefaultSize</span>(<span class="function">getSuggestedMinimumWidth</span>(), widthMeasureSpec),</span><br><span class="line">                <span class="function">getDefaultSize</span>(<span class="function">getSuggestedMinimumHeight</span>(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>onMeasure()方法只调用了setMeasuredDimension方法，setMeasuredDimension方法的作用是对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值。measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以一旦这两个变量被赋值意味着该View的测量工作结束。可以看到setMeasuredDimension方法的参数都是通过getDefaultSize()方法传入的。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * <span class="type">Utility</span> to <span class="keyword">return</span> a default size. <span class="type">Uses</span> the supplied size <span class="keyword">if</span> the</span><br><span class="line">    * <span class="type">MeasureSpec</span> imposed no constraints. <span class="type">Will</span> get larger <span class="keyword">if</span> allowed</span><br><span class="line">    * by the <span class="type">MeasureSpec</span>.</span><br><span class="line">    *</span><br><span class="line">    * @param size <span class="type">Default</span> size <span class="keyword">for</span> this view</span><br><span class="line">    * @param measureSpec <span class="type">Constraints</span> imposed by the parent</span><br><span class="line">    * @<span class="keyword">return</span> <span class="type">The</span> size this view should be.</span><br><span class="line">    */</span><br><span class="line">   //通过<span class="type">MeasureSpec</span>解析获取mode与size</span><br><span class="line"> //@param size参数一般表示设置了android:minHeight属性或者该<span class="type">View</span>背景图片的大小值</span><br><span class="line">   public <span class="keyword">static</span> <span class="type">int</span> getDefaultSize(<span class="type">int</span> size, <span class="type">int</span> measureSpec) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="literal">result</span> = size;</span><br><span class="line">       <span class="type">int</span> specMode = <span class="type">MeasureSpec</span>.getMode(measureSpec);</span><br><span class="line">       <span class="type">int</span> specSize = <span class="type">MeasureSpec</span>.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">	 //根据不同的mode值，取得宽和高的实际值。  </span><br><span class="line">       switch (specMode) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">UNSPECIFIED</span>: //表示该<span class="type">View</span>的大小父视图未定，设置为默认值  </span><br><span class="line">           <span class="literal">result</span> = size;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">AT_MOST</span>://表示该<span class="type">View</span>的大小由父视图指定了  </span><br><span class="line">       <span class="keyword">case</span> <span class="type">MeasureSpec</span>.<span class="type">EXACTLY</span>:</span><br><span class="line">           <span class="literal">result</span> = specSize;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> //获得设置了android:minHeight属性或者该<span class="type">View</span>背景图片的大小值， 作为该<span class="type">View</span>的参考</span><br><span class="line">   protected <span class="type">int</span> getSuggestedMinimumHeight() &#123;</span><br><span class="line">       <span class="keyword">return</span> (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">//getDefaultSize参数的widthMeasureSpec和heightMeasureSpec都是由父<span class="type">View</span>传递进来的</span><br><span class="line">   protected <span class="type">int</span> getSuggestedMinimumWidth() &#123;</span><br><span class="line">       <span class="keyword">return</span> (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>到了这里呢，非容器类的View的measure过程已经结束。</strong><br>但是对于父View，也就是ViewGroup类型，都需要在重写onMeasure()   方法，遍历所有子View，设置每个子View的大小。基本思想如下：遍历所有子View，设置每个子View的大小。</p>
<p>整个Measure流程图如下：</p>
<p><img src="http://cdn2.snapgram.co/imgs/2015/06/20/Viewmeasure.png" alt=""></p>
<h4 id="ViewGroup的Measure过程梳理">ViewGroup的Measure过程梳理</h4><p>   ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量，measureChildren内部实质只是循环调用measureChild，measureChild和measureChildWithMargins的区别就是是否把margin和padding也作为子视图的大小。 而widthMeasureSpec、heightMeasureSpec也是在ViewGroup中设置的，它们向子View传达了父View对其子View的布局要求。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Ask all of the children of this view to measure themselves, taking into</span><br><span class="line">     * account both the MeasureSpec requirements for this view and its padding.</span><br><span class="line">     * We skip children that are in the GONE state The heavy lifting is done in</span><br><span class="line">     * getChildMeasureSpec.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec The width requirements for this view</span><br><span class="line">     * @param heightMeasureSpec The height requirements for this view</span><br><span class="line">     */</span>  </span><br><span class="line">	<span class="comment">//遍历每个子View，然后调用measureChild()方法去实现每个子View大小  </span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> measureChildren(<span class="built_in">int</span> widthMeasureSpec, <span class="built_in">int</span> heightMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> <span class="built_in">size</span> = mChildrenCount;</span><br><span class="line">        <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">		<span class="comment">//依次遍历并measureViewGroup的每个子View</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<span class="comment">// 不处于 “GONE” 状态</span></span><br><span class="line">				<span class="comment">//widthMeasureSpec 和  heightMeasureSpec 表示该父View的布局要求</span></span><br><span class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*测量每个子View高宽时，清楚了该View本身的边距大小，即android:padding属性 或	</span><br><span class="line">    android:paddingLeft等属性标记*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> measureChild(View child, <span class="built_in">int</span> parentWidthMeasureSpec,</span><br><span class="line">            <span class="built_in">int</span> parentHeightMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();<span class="comment">// 获取View的LayoutParams属性  </span></span><br><span class="line"></span><br><span class="line">		  <span class="comment">/*设置子View的childWidthMeasureSpec属性，去除了该父View的边距值  mPaddingLeft + 			</span><br><span class="line">		  mPaddingRight*/</span></span><br><span class="line">		  </span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> childWidthMeasureSpec = </span><br><span class="line">        getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.<span class="variable">width</span>);</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">/*设置子View的childHeightMeasureSpec属性，去除了该父View的边距值  mPaddingTop + </span><br><span class="line">		 mPaddingBottom*/</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> childHeightMeasureSpec = </span><br><span class="line">        getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.<span class="variable">height</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调用到View的 measure(int widthMeasureSpec, int heightMeasureSpec)方法</span></span><br><span class="line">		<span class="comment">//因为该方法时是public final</span></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码的说明：</p>
<ul>
<li>measureChildren()方法：遍历所有子View，调用measureChild()方法去设置该子View的属性值。</li>
<li>measureChild()  方法   ： 获取特定子View的widthMeasureSpec、heightMeasureSpec，调<br>用measure()方法设置子View的实际宽高值。</li>
<li>getChildMeasureSpec()就是获取子View的widthMeasureSpec、heightMeasureSpec值。根据<br>父View的measureSpec值(widthMeasureSpec,heightMeasureSpec)值以及子View的子View内部<br>LayoutParams属性值，共同决定子View的measureSpec值的大小。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span><br><span class="line">    * Does the hard part of measureChildren: figuring out the MeasureSpec to</span><br><span class="line">    * pass to a particular child. This method figures out the right MeasureSpec</span><br><span class="line">    * for one dimension (height or width) of one child view.</span><br><span class="line">    *</span><br><span class="line">    * The goal is to combine information from our MeasureSpec with the</span><br><span class="line">    * LayoutParams of the child to get the best possible results. For example,</span><br><span class="line">    * if the this view knows its size (because its MeasureSpec has a mode of</span><br><span class="line">    * EXACTLY), and the child has indicated in its LayoutParams that it wants</span><br><span class="line">    * to be the same size as the parent, the parent should ask the child to</span><br><span class="line">    * layout given an exact size.</span><br><span class="line">    *</span><br><span class="line">    * @param spec The requirements for this view 表示该父View本身所占的widthMeasureSpec 或  heightMeasureSpec值</span><br><span class="line">    * @param padding The padding of this view for the current dimension and</span><br><span class="line">    *        margins, if applicable</span><br><span class="line"> * 表示该父View的边距大小，见于android:padding属性 或android:paddingLeft等属性标记  </span><br><span class="line">    * @param childDimension How big the child wants to be in the current</span><br><span class="line">    *        dimension 表示该子View内部LayoutParams属性的值，可以是wrap_content、match_parent、一个精确指(an exactly size),  例如：由android:width指定等。  </span><br><span class="line">    * @return a MeasureSpec integer for the child</span><br><span class="line">    */</span></span><br><span class="line"><span class="comment">//获取子View的widthMeasureSpec、heightMeasureSpec值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> getChildMeasureSpec(<span class="built_in">int</span> spec, <span class="built_in">int</span> padding, <span class="built_in">int</span> childDimension) &#123;</span><br><span class="line">	<span class="comment">//获取当前Parent View的Mode和Size</span></span><br><span class="line">       <span class="built_in">int</span> specMode = MeasureSpec.getMode(spec);<span class="comment">//获得父View的mode  </span></span><br><span class="line">       <span class="built_in">int</span> specSize = MeasureSpec.getSize(spec);<span class="comment">//获得父View的实际值  </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0</span></span><br><span class="line">       <span class="built_in">int</span> <span class="built_in">size</span> = Math.<span class="built_in">max</span>(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义返回值存储变量</span></span><br><span class="line">       <span class="built_in">int</span> resultSize = <span class="number">0</span>; <span class="comment">//子View对应地 size 实际值 ，由下面的逻辑条件赋值  </span></span><br><span class="line">       <span class="built_in">int</span> resultMode = <span class="number">0</span>;<span class="comment">//子View对应地 mode 值 ， 由下面的逻辑条件赋值 </span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">//依据当前Parent的Mode进行switch分支逻辑</span></span><br><span class="line">       <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">       <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">	<span class="comment">//默认Root View的Mode就是EXACTLY</span></span><br><span class="line">	<span class="comment">//1、父View是EXACTLY的 </span></span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">		<span class="comment">//如果child的layout_width属性在xml或者java中给予具体大于等于0的数值</span></span><br><span class="line">		<span class="comment">//设置child的size为真实layout_width属性值，mode为EXACTLY</span></span><br><span class="line">		<span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)</span></span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               resultSize = childDimension; <span class="comment">//size为精确值  </span></span><br><span class="line">               resultMode = MeasureSpec.EXACTLY; <span class="comment">//mode为 EXACTLY 。</span></span><br><span class="line">           &#125; </span><br><span class="line">		 <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">			<span class="comment">//如果child的layout_width属性在xml或者java中给予MATCH_PARENT</span></span><br><span class="line">               <span class="comment">//设置child的size为size，mode为EXACTLY</span></span><br><span class="line">               resultSize = <span class="built_in">size</span>;</span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">           &#125; </span><br><span class="line">		  <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">               <span class="comment">// bigger than us.</span></span><br><span class="line">			<span class="comment">//WRAP_CONTENT</span></span><br><span class="line">               <span class="comment">//设置child的size为size，mode为EXACTLY</span></span><br><span class="line">               resultSize = <span class="built_in">size</span>;</span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">	<span class="comment">//2、父View是AT_MOST的 ！</span></span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">		 <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size) </span></span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">               resultSize = childDimension;<span class="comment">//size为精确值  </span></span><br><span class="line">               resultMode = MeasureSpec.EXACTLY;<span class="comment">//mode为 EXACTLY</span></span><br><span class="line">           &#125; </span><br><span class="line">		<span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">               <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">               resultSize = <span class="built_in">size</span>;<span class="comment">//size为父视图大小  </span></span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;<span class="comment">//mode为AT_MOST  </span></span><br><span class="line">           &#125; </span><br><span class="line">		<span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">               <span class="comment">// bigger than us.</span></span><br><span class="line">               resultSize = <span class="built_in">size</span>;<span class="comment">//size为父视图大小  </span></span><br><span class="line">               resultMode = MeasureSpec.AT_MOST;<span class="comment">//mode为AT_MOST  </span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">	<span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">       <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">		<span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">           <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">               resultSize = childDimension;<span class="comment">//size为精确值 </span></span><br><span class="line">               resultMode = MeasureSpec.EXACTLY; <span class="comment">//mode为 EXACTLY </span></span><br><span class="line">           &#125; </span><br><span class="line">		<span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">               <span class="comment">// be</span></span><br><span class="line">               resultSize = <span class="number">0</span>;<span class="comment">//size为0！ ,其值未定 </span></span><br><span class="line">               resultMode = MeasureSpec.UNSPECIFIED; <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">           &#125; </span><br><span class="line">		 <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">               <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">               <span class="comment">// big it should be</span></span><br><span class="line">               resultSize = <span class="number">0</span>; <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">               resultMode = MeasureSpec.UNSPECIFIED;<span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。</span></span><br><span class="line">	<span class="comment">//将mode与size通过MeasureSpec方法整合为32位整数返回</span></span><br><span class="line">	<span class="comment">//返回给measureChildWithMargins方法</span></span><br><span class="line">       <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Measure原理总结">Measure原理总结</h4><p>   measure过程主要就是从顶层父View向子View递归调用view.measure方法（measure中又回调onMeasure方法）的过程。具体measure核心主要有如下几点：</p>
<ul>
<li><p>MeasureSpec（View的内部类）测量规格为int型,其中specMode只有三种值：</p>
<p>   MeasureSpec.EXACTLY //确定模式，父View希望子View的大小是确定的，由specSize决定；<br>   MeasureSpec.AT_MOST //最多模式，父View希望子View的大小最多是specSize指定的值；<br>   MeasureSpec.UNSPECIFIED //未指定模式，父View完全依据子View的设计值来决定；</p>
</li>
<li>View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。 </li>
<li>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定<br>的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</li>
<li>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了<br>父子View的尺寸计算。</li>
<li>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使<br>用layout_margin参数。</li>
<li>View的布局大小由父View和子View共同决定。</li>
<li>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证<br>这两个方法在onMeasure流程之后被调用才能返回有效值。<h4 id="Measure过程具体例子">Measure过程具体例子</h4></li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout android:<span class="variable">id=</span><span class="string">"@+id/my_layout"</span></span><br><span class="line">                xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">                xmlns:<span class="variable">tools=</span><span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">                android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span></span><br><span class="line">                android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span></span><br><span class="line">                tools:<span class="variable">context=</span><span class="string">".MainActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;TextView</span><br><span class="line">		android:<span class="variable">id=</span><span class="string">"@+id/my_text"</span></span><br><span class="line">		android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span></span><br><span class="line">		android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span></span><br><span class="line">		android:<span class="variable">text=</span><span class="string">"@string/hello_world"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>
<p>   对LinearLayout而言比较简单，由于 android:layout_width=”match_parent”，因此其width对<br>   应地widthSpec mode值为MeasureSpec.EXACTLY ， size由父视图大小指定 ;  由<br>   于android:layout_height = “match_parent”，因此其height对应地heightSpec mode值<br>   为MeasureSpec.EXACTLY，size由父视图大小指定 ;</p>
<p>   对TextView而言 ，其父View为LinearLayout的widthSpec和heightSpec值皆<br>   为MeasureSpec.EXACTLY类型，由于android:layout_width=”match_parent” ， 因此其width<br>   对应地widthSpec mode值为MeasureSpec.EXACTLY，size由父视图大小指定 ;  由<br>   于android:layout_width=”wrap_content” ， 因此其height对应地widthSpec mode值为<br>   MeasureSpec.AT_MOST，size由父视图大小指定 。</p>
<p>   接下俩，看一下LinearLayout类的measure过程</p>
<p>   前面已经讲过，View的子类只能通过重载onMeasure方法来完成measure过程。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断是垂直方向还是水平方向，这儿我们假设是VERTICAL垂直方向</span></span><br><span class="line">       <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">           measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以measureVertical进行进一步分析。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">     * Measures the children when the orientation of this LinearLayout is set</span><br><span class="line">     * to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.</span><br><span class="line">     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.</span><br><span class="line">     *</span><br><span class="line">     * @see #getOrientation()</span><br><span class="line">     * @see #setOrientation(int)</span><br><span class="line">     * @see #onMeasure(int, int)</span><br><span class="line">     */</span></span><br><span class="line">	<span class="comment">//垂直方向布局 </span></span><br><span class="line">    <span class="keyword">void</span> measureVertical(<span class="built_in">int</span> widthMeasureSpec, <span class="built_in">int</span> heightMeasureSpec) &#123;</span><br><span class="line">        mTotalLength = <span class="number">0</span>; <span class="comment">//该LinearLayout测量子View时的总高度</span></span><br><span class="line">        <span class="built_in">int</span> maxWidth = <span class="number">0</span>; <span class="comment">//保存子View中最大width值  </span></span><br><span class="line">        <span class="built_in">int</span> childState = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> alternativeMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> weightedMaxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">boolean</span> allFillParent = <span class="keyword">true</span>;</span><br><span class="line">        <span class="built_in">float</span> totalWeight = <span class="number">0</span>;<span class="comment">//所有子View的权重和 , android:layout_weight </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> count = getVirtualChildCount();<span class="comment">//子View的个数  </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取Mode类型</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// See how tall everyone is. Also remember max width.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">/*注意，我们将类型为 ViewGroup.LayoutParams的实例对象强制转换为了</span><br><span class="line">			LinearLayout.LayoutParams，即父对象转换为了子对象，能这样做的原因就</span><br><span class="line">			是LinearLayout的所有子View的LayoutParams类型都为LinearLayout.LayoutParams*/</span></span><br><span class="line">			 </span><br><span class="line">            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) </span><br><span class="line">            child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            totalWeight += lp.weight;</span><br><span class="line">            <span class="comment">//满足该条件地View会在该LinearLayout有剩余高度时，才真正调用measure() </span></span><br><span class="line">            <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY &amp;&amp; lp.<span class="variable">height</span> == <span class="number">0</span> &amp;&amp; lp.weight &gt; </span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">int</span> oldHeight = Integer.MIN_VALUE;</span><br><span class="line">				 <span class="comment">/*如果View的hight值为0，并且设置了android:layout_weight属性，重新纠正其 </span><br><span class="line">				 height值为WRAP_CONTENT*/</span>  </span><br><span class="line">                <span class="keyword">if</span> (lp.<span class="variable">height</span> == <span class="number">0</span> &amp;&amp; lp.weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// heightMode is either UNSPECIFIED or AT_MOST, and this</span></span><br><span class="line">                    <span class="comment">// child wanted to stretch to fill available space.</span></span><br><span class="line">                    <span class="comment">// Translate that to WRAP_CONTENT so that it does not end up</span></span><br><span class="line">                    <span class="comment">// with a height of 0</span></span><br><span class="line">                    oldHeight = <span class="number">0</span>;</span><br><span class="line">                    lp.<span class="variable">height</span> = LayoutParams.WRAP_CONTENT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Determine how big this child would like to be. If this or</span></span><br><span class="line">                <span class="comment">// previous children have given a weight, then we allow it to</span></span><br><span class="line">                <span class="comment">// use all available space (and we will shrink things later</span></span><br><span class="line">                <span class="comment">// if needed).</span></span><br><span class="line">				 <span class="comment">//对每个子View调用measure()方法  </span></span><br><span class="line">                measureChildBeforeLayout(</span><br><span class="line">                       child, i, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec,</span><br><span class="line">                       totalWeight == <span class="number">0</span> ? mTotalLength : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (oldHeight != Integer.MIN_VALUE) &#123;</span><br><span class="line">                   lp.<span class="variable">height</span> = oldHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/**这三行代码做了如下两件事情：  </span><br><span class="line">			* 1、获得该View的measuredHeight值，每个View都会根据他们地属性正确设置值  &gt; 0 ;  </span><br><span class="line">			* 2、更新mTotalLength值：取当前高度mTotalLength值与mTotalLength +</span><br><span class="line">			* childHeight的最大值.于是对于android:layout_height="wrap_height"属性地</span><br><span class="line">			* LinearLayout控件也就知道了它的确切高度值了。**/</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> totalLength = mTotalLength;</span><br><span class="line">                mTotalLength = Math.<span class="built_in">max</span>(totalLength, totalLength + childHeight + </span><br><span class="line">                lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line"></span><br><span class="line">               ...</span><br><span class="line">               &#125;</span><br><span class="line">				...</span><br><span class="line">                                   </span><br><span class="line">               child.measure(childWidthMeasureSpec,</span><br><span class="line">               ...</span><br><span class="line">                       </span><br><span class="line">		<span class="comment">//得到maxWidth</span></span><br><span class="line">        maxWidth += mPaddingLeft + mPaddingRight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check against our minimum width</span></span><br><span class="line">        maxWidth = Math.<span class="built_in">max</span>(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line">        </span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, </span><br><span class="line">        childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matchWidth) &#123;</span><br><span class="line">            forceUniformWidth(count, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看measureChildWithMargins方法,因为measureChildBeforeLayout方法是封装了对它的调用</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">void</span> measureChildBeforeLayout(View child, <span class="built_in">int</span> childIndex,</span><br><span class="line">           <span class="built_in">int</span> widthMeasureSpec, <span class="built_in">int</span> totalWidth, <span class="built_in">int</span> heightMeasureSpec,</span><br><span class="line">           <span class="built_in">int</span> totalHeight) &#123;</span><br><span class="line">       measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">               heightMeasureSpec, totalHeight);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Ask one of the children of this view to measure itself, taking into</span><br><span class="line">    * account both the MeasureSpec requirements for this view and its padding</span><br><span class="line">    * and margins. The child must have MarginLayoutParams The heavy lifting is</span><br><span class="line">    * done in getChildMeasureSpec.</span><br><span class="line">    *</span><br><span class="line">    * @param child The child to measure</span><br><span class="line">    * @param parentWidthMeasureSpec The width requirements for this view</span><br><span class="line">    * @param widthUsed Extra space that has been used up by the parent</span><br><span class="line">    *        horizontally (possibly by other children of the parent)</span><br><span class="line">    * @param parentHeightMeasureSpec The height requirements for this view</span><br><span class="line">    * @param heightUsed Extra space that has been used up by the parent</span><br><span class="line">    *        vertically (possibly by other children of the parent)</span><br><span class="line">    */</span></span><br><span class="line"><span class="comment">//基本流程同于measureChild()方法，但添加了对子View Margin的处理，即：android:margin属性或者android:marginLeft等属性的处理  </span></span><br><span class="line"><span class="comment">//widthUsed参数  表示该父View已经使用的宽度  </span></span><br><span class="line"><span class="comment">//heightUsed参数  表示该父View已经使用的高度  </span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> measureChildWithMargins(View child,</span><br><span class="line">           <span class="built_in">int</span> parentWidthMeasureSpec, <span class="built_in">int</span> widthUsed,</span><br><span class="line">           <span class="built_in">int</span> parentHeightMeasureSpec, <span class="built_in">int</span> heightUsed) &#123;</span><br><span class="line">	 <span class="comment">//获取子视图的LayoutParams</span></span><br><span class="line">       <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调整MeasureSpec</span></span><br><span class="line">       <span class="comment">//通过这两个参数以及子视图本身的LayoutParams来共同决定子视图的测量规格</span></span><br><span class="line">       <span class="keyword">final</span> <span class="built_in">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">               mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                       + widthUsed, lp.<span class="variable">width</span>);</span><br><span class="line">       <span class="keyword">final</span> <span class="built_in">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">               mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                       + heightUsed, lp.<span class="variable">height</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调运子View的measure方法，子View的measure中会回调子View的onMeasure方法</span></span><br><span class="line">       child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可见，measureChildWithMargins()方法的基本流程同于measureChild()方法，但添加了对子View Margin的处理，即：android:margin属性或者android:marginLeft等属性的处理。</p>
<p>至此，关于Measure的内容完全结束。</p>
<h3 id="Layout过程">Layout过程</h3><p>回到最初的那行代码</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用View.layout()方法</span></span><br><span class="line">host.layout<span class="comment">(0, 0, host.getMeasuredWidth()</span>, host.getMeasuredHeight<span class="comment">()</span>);</span><br></pre></td></tr></table></figure>
<p>   layout方法的四个参数分别代表子View在父View中的相对坐标。可见上，左都是0，而右(width)，下(height)则是测量值。</p>
<p>   那么，接下来让我们又回到View.java进行查看。而整个View.layout()的流程也是通过递归来完成的，整体和measure的流程图几乎一样。<br>   <img src="http://cdn2.snapgram.co/imgs/2015/06/20/ViewLayout.png" alt=""><br>  接下来，就是查看源码了：</p>
<h4 id="Layout过程梳理">Layout过程梳理</h4> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">    * <span class="type">Assign</span> a size <span class="keyword">and</span> position to a view <span class="keyword">and</span> all <span class="keyword">of</span> its</span><br><span class="line">    * descendants</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;<span class="type">This</span> <span class="keyword">is</span> the second phase <span class="keyword">of</span> the layout mechanism.</span><br><span class="line">    * (<span class="type">The</span> first <span class="keyword">is</span> measuring). <span class="type">In</span> this phase, each parent calls</span><br><span class="line">    * layout on all <span class="keyword">of</span> its children to position them.</span><br><span class="line">    * <span class="type">This</span> <span class="keyword">is</span> typically done <span class="keyword">using</span> the child measurements</span><br><span class="line">    * that were stored <span class="keyword">in</span> the measure pass().&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;<span class="type">Derived</span> classes should <span class="keyword">not</span> override this <span class="keyword">method</span>.</span><br><span class="line">    * <span class="type">Derived</span> classes <span class="keyword">with</span> children should override</span><br><span class="line">    * onLayout. <span class="type">In</span> that <span class="keyword">method</span>, they should</span><br><span class="line">    * call layout on each <span class="keyword">of</span> their children.&lt;/p&gt;</span><br><span class="line">    *</span><br><span class="line">    * @param l <span class="type">Left</span> position, relative to parent</span><br><span class="line">    * @param t <span class="type">Top</span> position, relative to parent</span><br><span class="line">    * @param r <span class="type">Right</span> position, relative to parent</span><br><span class="line">    * @param b <span class="type">Bottom</span> position, relative to parent</span><br><span class="line">    */</span><br><span class="line">   @<span class="type">SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">//<span class="type">View</span>自身调用来进行layout()过程</span><br><span class="line">   public <span class="type">void</span> layout(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b) &#123;</span><br><span class="line">       <span class="type">int</span> oldL = mLeft;</span><br><span class="line">       <span class="type">int</span> oldT = mTop;</span><br><span class="line">       <span class="type">int</span> oldB = mBottom;</span><br><span class="line">       <span class="type">int</span> oldR = mRight;</span><br><span class="line">	//实质都是调用setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量</span><br><span class="line">       //判断<span class="type">View</span>的位置是否发生过变化，以确定有没有必要对当前的<span class="type">View</span>进行重新layout</span><br><span class="line">       boolean changed = setFrame(l, t, r, b);</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (changed || (mPrivateFlags &amp; <span class="type">PFLAG_LAYOUT_REQUIRED</span>) == <span class="type">PFLAG_LAYOUT_REQUIRED</span>) &#123; //需要重新layout</span><br><span class="line">           onLayout(changed, l, t, r, b);//该方法的body为空,所以需要具体的<span class="type">ViewGroup</span>来实现,如<span class="type">LinearLayout</span></span><br><span class="line">           mPrivateFlags &amp;= ~<span class="type">PFLAG_LAYOUT_REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">           <span class="type">ListenerInfo</span> li = mListenerInfo;</span><br><span class="line">           <span class="keyword">if</span> (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123;</span><br><span class="line">               <span class="type">ArrayList</span>&lt;<span class="type">OnLayoutChangeListener</span>&gt; listenersCopy =</span><br><span class="line">                       (<span class="type">ArrayList</span>&lt;<span class="type">OnLayoutChangeListener</span>&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">               <span class="type">int</span> numListeners = listenersCopy.size();</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                   listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       mPrivateFlags &amp;= ~<span class="type">PFLAG_FORCE_LAYOUT</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同样，这里也是调用了onLayout()方法</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Called from layout when this view should</span><br><span class="line">    * assign a size <span class="keyword">and</span> position <span class="keyword">to</span> <span class="keyword">each</span> of its children.</span><br><span class="line">    *</span><br><span class="line">    * <span class="built_in">Derived</span> classes <span class="keyword">with</span> children should override</span><br><span class="line">    * this method <span class="keyword">and</span> <span class="keyword">call</span> layout <span class="keyword">on</span> <span class="keyword">each</span> of</span><br><span class="line">    * their children.</span><br><span class="line">    * @param changed This <span class="keyword">is</span> a <span class="keyword">new</span> size <span class="keyword">or</span> position <span class="keyword">for</span> this view</span><br><span class="line">    * @param <span class="built_in">left</span> <span class="built_in">Left</span> position, relative <span class="keyword">to</span> parent</span><br><span class="line">    * @param top Top position, relative <span class="keyword">to</span> parent</span><br><span class="line">    * @param <span class="built_in">right</span> <span class="built_in">Right</span> position, relative <span class="keyword">to</span> parent</span><br><span class="line">    * @param bottom Bottom position, relative <span class="keyword">to</span> parent</span><br><span class="line">    */</span><br><span class="line">   protected void onLayout(boolean changed, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> top, <span class="built_in">int</span> <span class="built_in">right</span>, <span class="built_in">int</span> bottom) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>呵呵，看到了吧。onLayout方法是空的。接下来，再看看ViewGroup中的onLayout方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>竟然是一个抽象方法，这就说明，Layout()方法只能由ViewGroup的子类来重载了。既然如此，那我么就看看LinearLayout里面的实现吧。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span><span class="comment">//Layout 过程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="typename">void</span> onLayout(<span class="typename">boolean</span> changed, <span class="typename">int</span> l, <span class="typename">int</span> t, <span class="typename">int</span> r, <span class="typename">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mOrientation == VERTICAL) &#123;</span><br><span class="line">            layoutVertical();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layoutHorizontal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以layoutVertical()为例， layoutHorizontal()同理</span></span><br><span class="line"> <span class="javadoc">/**</span><br><span class="line">     * Position the children during a layout pass if the orientation of this</span><br><span class="line">     * LinearLayout is set to &#123;@link #VERTICAL&#125;.</span><br><span class="line">     *</span><br><span class="line">     *<span class="javadoctag"> @see</span> #getOrientation()</span><br><span class="line">     *<span class="javadoctag"> @see</span> #setOrientation(int)</span><br><span class="line">     *<span class="javadoctag"> @see</span> #onLayout(boolean, int, int, int, int)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="typename">void</span> layoutVertical() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        <span class="typename">int</span> childTop;</span><br><span class="line">        <span class="typename">int</span> childLeft;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Where right end of child should go</span></span><br><span class="line">		<span class="comment">//计算父窗口推荐的子View宽度</span></span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> width = mRight - mLeft;</span><br><span class="line">		 <span class="comment">//计算父窗口推荐的子View右侧位置</span></span><br><span class="line">        <span class="typename">int</span> childRight = width - mPaddingRight;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Space available for child</span></span><br><span class="line">		<span class="comment">//child可使用空间大小</span></span><br><span class="line">        <span class="typename">int</span> childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//通过ViewGroup的getChildCount方法获取ViewGroup的子View个数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> count = getVirtualChildCount();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取Gravity属性设置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">        <span class="keyword">final</span> <span class="typename">int</span> minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//依据majorGravity计算childTop的位置值</span></span><br><span class="line">        <span class="keyword">switch</span> (majorGravity) &#123;</span><br><span class="line">           <span class="keyword">case</span> Gravity.<span class="string">BOTTOM:</span></span><br><span class="line">               <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">               childTop = mPaddingTop + mBottom - mTop - mTotalLength;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// mTotalLength contains the padding already</span></span><br><span class="line">           <span class="keyword">case</span> Gravity.<span class="string">CENTER_VERTICAL:</span></span><br><span class="line">               childTop = mPaddingTop + (mBottom - mTop - mTotalLength) / <span class="number">2</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> Gravity.<span class="string">TOP:</span></span><br><span class="line"><span class="label">           default:</span></span><br><span class="line">               childTop = mPaddingTop;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//开始遍历每个子View，即为每个子View进行layout</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="typename">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getVirtualChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">                childTop += measureNullChild(i);<span class="comment">//return 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">				<span class="comment">//子View测量所得width和height</span></span><br><span class="line">				<span class="comment">//LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的</span></span><br><span class="line">				<span class="comment">//意义就是为layout过程提供视图显示范围的参考值</span></span><br><span class="line">                <span class="keyword">final</span> <span class="typename">int</span> childWidth = child.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">final</span> <span class="typename">int</span> childHeight = child.getMeasuredHeight();</span><br><span class="line">                </span><br><span class="line">				 <span class="comment">//获取子View的LayoutParams</span></span><br><span class="line">                <span class="keyword">final</span> LinearLayout.LayoutParams lp =</span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line">                </span><br><span class="line">                <span class="typename">int</span> gravity = lp.gravity;</span><br><span class="line">                <span class="keyword">if</span> (gravity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    gravity = minorGravity;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="typename">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">                <span class="keyword">final</span> <span class="typename">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">				<span class="comment">//依据不同的absoluteGravity计算childLeft位置</span></span><br><span class="line">                <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Gravity.<span class="string">CENTER_HORIZONTAL:</span></span><br><span class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / <span class="number">2</span>)</span><br><span class="line">                                + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Gravity.<span class="string">RIGHT:</span></span><br><span class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Gravity.<span class="string">LEFT:</span></span><br><span class="line"><span class="label">                    default:</span></span><br><span class="line">                        childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                    childTop += mDividerHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                childTop += lp.topMargin;</span><br><span class="line">				<span class="comment">//通过setChildFrame的封装调用View.layout()方法</span></span><br><span class="line">				 <span class="comment">//通过垂直排列计算调运child的layout设置child的位置</span></span><br><span class="line">                setChildFrame(child, childLeft, childTop + </span><br><span class="line">                getLocationOffset(child),</span><br><span class="line">                        childWidth, childHeight);</span><br><span class="line">                childTop += childHeight + lp.bottomMargin + </span><br><span class="line">                getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>   可以看到layout过程会参考measure过程中计算得到的mMeasuredWidth和mMeasuredHeight来安排<br>   子View在父View中显示的位置只能作为参考。同时也应记住，getMeasuredWidth()<br>   、getMeasuredHeight()必须在onMeasure之后使用才有效；而getWidth()与getHeight()方法必须<br>   在layout(int l, int t, int r, int b)执行之后才有效。</p>
<h4 id="Layout原理总结">Layout原理总结</h4><p>   layout过程也是从View树自顶向下进行的。父View会根据measure所得到的数据将子View放在正确的<br>   位置，并设置合适的宽高。</p>
<ul>
<li>layout完成后得到的每个子View的坐标都是相对于它的parent的，如mTop，mRight，mBottom，<br>mLeft。而measure所得到的measuredWidth和measuredHeight经过计算得出的绝对坐标。</li>
<li>使用View的getWidth()和getHeight()方法必须在该View layout完成之后。</li>
<li>View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为<br>abstract的，子类必须重载实现自己的位置逻辑。</li>
</ul>
<h3 id="Draw过程">Draw过程</h3><p>draw()的调用位置和之前的两个方法的调用位置一样。draw过程的流程图如下</p>
<p><img src="http://cdn1.snapgram.co/imgs/2015/06/20/ViewDraw.png" alt=""></p>
<h4 id="Draw过程梳理">Draw过程梳理</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Manually render this view (and all of its children) to the given Canvas.</span><br><span class="line">     * The view must have already done a full layout before this function is</span><br><span class="line">     * called.  When implementing a view, implement</span><br><span class="line">     * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method.</span><br><span class="line">     * If you do need to override this method, call the superclass version.</span><br><span class="line">     *</span><br><span class="line">     * @param canvas The Canvas to which the View is rendered.</span><br><span class="line">     */</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span>(Canvas canvas) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == </span><br><span class="line">        PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">                (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">         * in the appropriate order:</span><br><span class="line">         *</span><br><span class="line">         *      1. Draw the background</span><br><span class="line">         *      2. If necessary, save the canvas' layers to prepare for fading</span><br><span class="line">         *      3. Draw view's content</span><br><span class="line">         *      4. Draw children</span><br><span class="line">         *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">         *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">        <span class="built_in">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">			<span class="comment">//获取xml中通过android:background属性或者代码中setBackgroundColor()、</span></span><br><span class="line">			<span class="comment">//setBackgroundResource()等方法进行赋值的背景Drawable</span></span><br><span class="line">            <span class="keyword">final</span> Drawable <span class="built_in">background</span> = mBackground;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">background</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> scrollX = mScrollX;</span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> scrollY = mScrollY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mBackgroundSizeChanged) &#123;</span><br><span class="line">                    <span class="built_in">background</span>.setBounds(<span class="number">0</span>, <span class="number">0</span>,  mRight - mLeft, mBottom - mTop);</span><br><span class="line">                    mBackgroundSizeChanged = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((scrollX | scrollY) == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">//调用Drawable的draw()方法来完成背景的绘制工作</span></span><br><span class="line">                    <span class="built_in">background</span>.<span class="title">draw</span>(canvas);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    canvas.<span class="built_in">translate</span>(scrollX, scrollY);</span><br><span class="line">                    <span class="built_in">background</span>.<span class="title">draw</span>(canvas);</span><br><span class="line">                    canvas.<span class="built_in">translate</span>(-scrollX, -scrollY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">int</span> viewFlags = mViewFlags;</span><br><span class="line">        <span class="built_in">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">            <span class="comment">// Step 3, draw the content</span></span><br><span class="line">            <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 4, draw the children</span></span><br><span class="line">            dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">            onDrawScrollBars(canvas);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we're done...</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Here we do the full fledged routine...</span><br><span class="line">         * (this is an uncommon case where speed matters less,</span><br><span class="line">         * this is why we repeat some of the tests that have been</span><br><span class="line">         * done above)</span><br><span class="line">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">boolean</span> drawTop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="built_in">boolean</span> drawBottom = <span class="keyword">false</span>;</span><br><span class="line">        <span class="built_in">boolean</span> drawLeft = <span class="keyword">false</span>;</span><br><span class="line">        <span class="built_in">boolean</span> drawRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> topFadeStrength = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">float</span> bottomFadeStrength = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">float</span> leftFadeStrength = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">float</span> rightFadeStrength = <span class="number">0.0</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2, save the canvas' layers</span></span><br><span class="line">        <span class="built_in">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">boolean</span> offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">        <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">            paddingLeft += getLeftPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> left = mScrollX + paddingLeft;</span><br><span class="line">        <span class="built_in">int</span> right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">        <span class="built_in">int</span> top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">        <span class="built_in">int</span> bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">            right += getRightPaddingOffset();</span><br><span class="line">            bottom += getBottomPaddingOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">float</span> fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">        <span class="built_in">int</span> length = (<span class="built_in">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">        <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">        <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">            length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">            length = (right - left) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">            topFadeStrength = Math.<span class="built_in">max</span>(<span class="number">0.0</span>f, Math.<span class="built_in">min</span>(<span class="number">1.0</span>f, getTopFadingEdgeStrength()));</span><br><span class="line">            drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0</span>f;</span><br><span class="line">            bottomFadeStrength = Math.<span class="built_in">max</span>(<span class="number">0.0</span>f, Math.<span class="built_in">min</span>(<span class="number">1.0</span>f, getBottomFadingEdgeStrength()));</span><br><span class="line">            drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0</span>f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">            leftFadeStrength = Math.<span class="built_in">max</span>(<span class="number">0.0</span>f, Math.<span class="built_in">min</span>(<span class="number">1.0</span>f, getLeftFadingEdgeStrength()));</span><br><span class="line">            drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0</span>f;</span><br><span class="line">            rightFadeStrength = Math.<span class="built_in">max</span>(<span class="number">0.0</span>f, Math.<span class="built_in">min</span>(<span class="number">1.0</span>f, getRightFadingEdgeStrength()));</span><br><span class="line">            drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0</span>f;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> solidColor = getSolidColor();</span><br><span class="line">        <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="built_in">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">                canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">                canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);<span class="comment">//均需要子类自己来实现</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);<span class="comment">//均需要子类自己来实现</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">        <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">        <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">        <span class="keyword">final</span> Shader fade = scrollabilityCache.<span class="built_in">shader</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">            matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">            matrix.postTranslate(left, bottom);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">            matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">            matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">            matrix.postTranslate(right, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">        onDrawScrollBars(canvas);<span class="comment">//onDrawScrollBars为protected final </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注释很清晰，整个Draw流程一共可以分为六个步骤，而且如果可以的话步骤2和5是可以跳过的。</p>
<p><strong>第一步</strong>主要是完成背景的绘制，具体的可见注释。</p>
<p><strong>第二步</strong>主要是对canvas进行保存，以实现渐变效果</p>
<p><strong>第三步</strong>是绘制View，该onDraw()方法需要具体的子类来实现。</p>
<p><strong>第四步</strong>主要是绘制View的子View，同样在View里面 dispatchDraw(canvas)方法也是空的。很明显，这个方法需要View的容器来实现。而通过查找源码发现RelativeLayout，LinearLayout等并没有实现该方法。最后查看ViewGroup.java发现ViewGroup实现了dispatchDraw(canvas)。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">count</span> = mChildrenCount;</span><br><span class="line">      <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">      <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> cache = (mGroupFlags &amp; FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> buildCache = !isHardwareAccelerated();</span><br><span class="line">	<span class="comment">//ViewGroup重载了View的dispatchDraw方法,并遍历自己的所有children,然后调用</span></span><br><span class="line">	<span class="comment">//drawChild方法</span></span><br><span class="line">         </span><br><span class="line">         ...</span><br><span class="line">         </span><br><span class="line">      <span class="keyword">if</span> ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> View child = children[i];</span><br><span class="line">              <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || </span><br><span class="line">              child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//drawChild()方法封装了View.draw()方法的调用</span></span><br><span class="line">                  more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> View child = children[getChildDrawingOrder(<span class="keyword">count</span>, i)];</span><br><span class="line">              <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || </span><br><span class="line">              child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Draw any disappearing views that have animations</span></span><br><span class="line">      <span class="keyword">if</span> (mDisappearingChildren != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">final</span> ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> disappearingCount = disappearingChildren.<span class="keyword">size</span>() - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// Go backwards -- we may delete as animations finish</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = disappearingCount; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">              <span class="keyword">final</span> View child = disappearingChildren.get(i);</span><br><span class="line">              more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span><br><span class="line">   * Draw one child of this View Group. This method is responsible for getting</span><br><span class="line">   * the canvas in the right state. This includes clipping, translating so</span><br><span class="line">   * that the child's scrolled origin is at 0, 0, and applying any animation</span><br><span class="line">   * transformations.</span><br><span class="line">   *</span><br><span class="line">   * @param canvas The canvas on which to draw the child</span><br><span class="line">   * @param child Who to draw</span><br><span class="line">   * @param drawingTime The time at which draw is occurring</span><br><span class="line">   * @return True if an invalidate() was issued</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> drawChild(Canvas canvas, View child, <span class="keyword">long</span> drawingTime) &#123;</span><br><span class="line">      <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，protected void dispatchDraw方法调用了drawChild方法，而drawChild方法回调了View.draw()方法，所以最终我们又回到了View.java。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">/**</span><br><span class="line">  * <span class="type">This</span> <span class="keyword">method</span> <span class="keyword">is</span> called by <span class="type">ViewGroup</span>.drawChild() to have each child view draw itself.</span><br><span class="line">  * <span class="type">This</span> draw() <span class="keyword">method</span> <span class="keyword">is</span> an implementation detail <span class="keyword">and</span> <span class="keyword">is</span> <span class="keyword">not</span> intended to be overridden <span class="keyword">or</span></span><br><span class="line">  * to be called <span class="keyword">from</span> anywhere <span class="keyword">else</span> other than <span class="type">ViewGroup</span>.drawChild().</span><br><span class="line">  */</span><br><span class="line"> boolean draw(<span class="type">Canvas</span> canvas, <span class="type">ViewGroup</span> parent, long drawingTime) &#123;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   通过注释可以看到，该方法是被ViewGroup.drawChild()回调，用来让child View完成对自身的绘制。<br>   主要涉及到View的加载动画，cache，alpha等方面。<br><strong>第五步</strong>负责绘制渐变效果，并存储相关的layers</p>
<p><strong>第六步</strong>则是完成对滚动条的绘制，可参考ScrollView等。</p>
<h4 id="Draw流程总结">Draw流程总结</h4><p>一些关键的方法</p>
<ul>
<li><p>drawChild(canvas, this, drawingTime)<br>直接调用了 View 的child.draw(canvas, this,drawingTime)方法，文档中也说明了，除了<br>被ViewGroup.drawChild()方法外，你不应该在其它任何地方去复写或调用该方法，它属于 ViewGroup。<br>而View.draw(Canvas)方法是我们自定义控件中可以复写的方法，具体可以参考上述对view.draw(Canvas<br>)的说明。从参数中可以看到，child.draw(canvas, this, drawingTime) 肯定是处理了和父视图相关<br>的逻辑，但 View 的最终绘制，还是 View.draw(Canvas)方法。</p>
</li>
<li><p>invalidate()<br>请求重绘 View 树，即 draw 过程，假如视图发生大小没有变化就不会调用layout()过程，并且只绘制那些<br>调用了invalidate()方法的 View。</p>
</li>
<li><p>requestLayout()<br>当布局变化的时候，比如方向变化，尺寸的变化，会调用该方法，在自定义的视图中，如果某些情况下希望重新<br>测量尺寸大小，应该手动去调用该方法，它会触发measure()和layout()过程，但不会进行 draw。</p>
</li>
</ul>
<h2 id="结语">结语</h2><p><strong>至此，View绘制流程便结束了。后期会对View绘制中的一些重要方法进行学习。</strong></p>
<p>今天看到一句很喜欢的话，作为结束吧。</p>
<p><strong>要么学习；要么健身。别在最美的时光里变成胖子！</strong></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/06/21/android-View-不同状态分析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          android View 不同状态分析
        
      </div>
    </a>
  
  
    <a href="/2015/06/17/Java常用XML解析方式/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java常用XML解析方式</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android-View-详解-二" data-title="android View 详解(二)" data-url="http://canglangwenyue.com/2015/06/18/android-View-详解-二/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 季高
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>