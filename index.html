<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wenyue‘s Blog</title>
  <meta name="author" content="Wenyue">
  
  <meta name="description" content="java web android">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Wenyue‘s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Wenyue‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">Wenyue‘s Blog</div>
		</a>

		
			<div id="subtitle">他年我若为青帝，抱死桃花一处开!</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/canglangwenyue" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/u/5578954920" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:canglangwenyue@icloud.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-03-30T12:35:38.000Z"><a href="/2015/03/30/我的2014_2015/">周一, 3月 30 2015, 8:35:38 晚上</a></time>

  
    <h1 class="title"><a href="/2015/03/30/我的2014_2015/">我的2014_2015</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/点滴/">点滴</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <pre><code>话说，2014年已经逝去很久很久了，马上就是2015年四月了。今天中午回到学校，恰逢后天是四月一日。因为
曾今自己的一个目标的起点便是四月一日。所以，决定在今天写点东西，权当是记录自己的成长轨迹，也希望对
如我一般的后来者有所帮助。记得曾今我写过一篇文章，记录自己的心情，而今这片算是在当时的基础上进一步
确定了自己的目标吧。
</code></pre><p><a href="http://canglangwenyue.com/2014/12/03/%E5%86%99%E7%BB%99%E6%88%91%E4%B8%A4%E5%B9%B4%E9%9B%B6%E4%B8%89%E4%B8%AA%E6%9C%88%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/" target="_blank" rel="external">写给我的两年零三个月的大学生活</a></p>
<pre><code>曾今的我很犹豫，也很迷茫，现在依旧是在不断的摸索。曾今我计划拿到里巴巴的实习offer；而今，我提前
完成了自己的目标，于2015年三月十九日拿到了阿里巴巴的实习offer，并同意了意向书。之后又拿到了另外
一些公司的offer，其中有几个很不错的创业团队，大多是B轮这样的。当然，时至今日，我下定决心先去阿里
发展了，这里面涉及到很多的原因与纠结。
</code></pre><h6 id="#当然，说了很多，只为记录自己走过的路，和对未来的展望。经了挺多事，接触了不少大牛，其实我现在才意识到：">#当然，说了很多，只为记录自己走过的路，和对未来的展望。经了挺多事，接触了不少大牛，其实我现在才意识到：</h6><h2 id="所谓大牛不过是在某一领域持续的投入和对时机的把握吧。只要你有很高的执行效率，并坚持付出，不需多久，你自可在某一专注领域崭露头角"><strong>所谓大牛不过是在某一领域持续的投入和对时机的把握吧。只要你有很高的执行效率，并坚持付出，不需多久，你自可在某一专注领域崭露头角</strong></h2><p>所以，这个世界你付出了，并且能够抓住机会，那么你总可以做些什么。</p>
<p>最后，基于最近的一些列面试，我想制定自己的接下来的学习计划：</p>
<pre><code><span class="number">1.</span>重新学习<span class="keyword">C</span>和<span class="keyword">C</span>++，虽然曾今投入了很多，但是随着学习的深入，我才意识到这一块的重要性；

<span class="number">2.</span>回头学习计算机组成结构相关课程，为后来的学习做铺垫；

<span class="number">3.</span>学习Linux相关知识，是真正的深入学习，而非之前的了解；

<span class="number">4.</span>阅读android源码，并学习源码，而非简单地理解所谓的机制，要结合Linux层考虑它的实现，多问What，
How，Why；

<span class="number">5.</span>回头复习中等程度的算法，并尝试在android开发中运用更多的设计模式，曾今在做java web时用的较多
，现在发觉这一块值得花更多时间来投入；

<span class="number">6.</span>将敏捷开发技能真正用于开发，而非停留在书本，如TDD之类；
</code></pre><p>以上，可以算是我之后的成长之路吧，权当记录自己的脚步，亦希望能够对以后和我面对同样境地的人有所帮助。仍然用我最喜欢的那句话结束这篇牢骚文吧:”他年我若为青帝，抱死桃花一处开”。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/03/30/我的2014_2015/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2015/03/30/我的2014_2015/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/03/30/我的2014_2015/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-03-04T02:04:58.000Z"><a href="/2015/03/04/android-intent-机制/">周三, 3月 4 2015, 10:04:58 上午</a></time>

  
    <h1 class="title"><a href="/2015/03/04/android-intent-机制/">android Intent 机制</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>一. Intent 对象</p>
<p>1.1什么是Intent</p>
<p>首先呢，大家要明确一点android时基于组件的应用开发。所以，开发过程中我们不仅要寻找和构造符合需求的组件，更重要的是，要将组件有机的连接起来，互相交换信息，这样才能构建出我们最终想要的应用程序。所以，intent便是用来组件之间连接并通信的模式。</p>
<p>1.2.Intent 的构成</p>
<pre><code>(<span class="number">1</span>) <span class="keyword">Action</span>项(谓语)
在<span class="type">Intent</span>对象中用<span class="keyword">Action</span>来表达动作，当调用组件指定一个<span class="keyword">Action</span>后，执行组件就会按照这个<span class="keyword">Action</span>的指示执行相关操作；
(<span class="number">2</span>) <span class="type">Data</span>项(宾语)
当调用组件(主语)发起请求时，如果该组件有明确的数据对象，通常就会用<span class="type">Data</span>项来进行存储。
(<span class="number">3</span>) <span class="keyword">Type</span>项
<span class="type">Data</span>用于描述具体操作目标的需求，例如：“我（调用组件）喝（<span class="keyword">Action</span>动作）王老吉（<span class="type">Data</span>项）”。而<span class="keyword">Type</span>就用于表示“我喝饮料”。即：<span class="type">Data</span>用于特指，而<span class="keyword">Type</span>用于泛指。
(<span class="number">4</span>) Category项
Category用于表述在特定场合下的约束条件。例如：“当我口渴的时候，我喝王老吉”，说明“口渴了”是“喝王老吉”这个<span class="type">Intent</span>的条件。
(<span class="number">5</span>) Component项
Component项指的是目标组件的类型信息。制定了Component后，<span class="type">Intent</span>就变成了单纯的信息载体只负责传递消息和数据。
(<span class="number">6</span>) Extras项
Extras项是<span class="type">Intent</span>数据传输的载体负责将数据从调用组件传递到实现组件。
(<span class="number">7</span>)    Flags 项
Flags是一个整型数，是调用组件指定组件管理服务构造实现组件的方式。
</code></pre><p> 1.3.Intent 的分类</p>
<pre><code>(<span class="number">1</span>) 在意图机制中，组件管理服务负责接受和分析<span class="type">Intent</span>对象，为调用组件选择最合适的实现组件。从实现组件的选择来看，<span class="type">Intent</span>对象可以分成两类：精确描述的 <span class="type">Intent</span>(Explicit <span class="type">Intent</span>－显示<span class="type">Intent</span>)和模糊描述的<span class="type">Intent</span>(<span class="type">Implicit</span> <span class="type">Intent</span> －隐式<span class="type">Intent</span>)。
</code></pre><p>1.4 Intent Filter 对象</p>
<pre><code><span class="type">Intent</span> Filter是各个组件用于描述其功能的，通过组建的<span class="type">Intent</span> Filter信息，android组件管理应用就可以掌握各个组件所具备的能力和可以处理的请求。而且，<span class="type">Intent</span> Filter对象的每个数据项的结构和含义，与<span class="type">Intent</span>中的数据项一一对应。
</code></pre><p>二. Intent匹配</p>
<p>1.Intent 匹配的算法流程</p>
<pre><code><span class="number">1.1</span> <span class="keyword">Action</span> 的比较：
每个<span class="type">Intent</span> Filter 对象都必须包含<span class="keyword">Action</span>信息，如果没有，则对任何一个<span class="type">Intent</span>对象，都会匹配失败。
<span class="number">1.2</span> <span class="type">Data</span> 和 <span class="keyword">Type</span> 的比较
<span class="number">1.3</span> Category 的比较
</code></pre><p>三. Intent 的使用</p>
<p>1.显式调用</p>
<p>显式调用时必须制定组件名称，例如：</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> ＝ new <span class="type">Intent</span>();
<span class="type">intent</span>.setClass(A.this,B.<span class="keyword">class</span>);        //指定了调用组件和实现组件
A.this.startActivity(<span class="type">intent</span>);
</code></pre><p>2.隐式调用</p>
<p>（1）隐式调用并传递Extra附加数据与静态广播的使用</p>
<pre><code>首先实现<span class="type">Intent</span>的调用代码

<span class="type">Intent</span> intent_BroaadCast = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="string">"Intent_1112"</span>);
intent_BroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"LA_LA_LA"</span>);
<span class="type">MainActivity</span>.<span class="keyword">this</span>.sendBroadcast(intent_BroaadCast);

实现静态<span class="type">BroadCastReceiver</span>

<span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.<span class="type">BroadcastReceiver</span>;
<span class="keyword">import</span> android.content.<span class="type">Context</span>;
<span class="keyword">import</span> android.content.<span class="type">Intent</span>;
<span class="keyword">import</span> android.widget.<span class="type">Toast</span>;

<span class="comment">/**
 * Created by canglangwenyue on 15-3-5.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">TestBroadCastReceiver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BroadcastReceiver</span> {</span>
    <span class="annotation">@Override</span>
    public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) {
        <span class="type">Toast</span>.makeText(context,                         intent.getExtras().getString(<span class="string">"StringTest"</span>),<span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>).show();
    }
}

注册<span class="type">Receiver</span>

&lt;receiver android:name=<span class="string">".TestBroadCastReceiver"</span>&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=<span class="string">"Intent_1112"</span>&gt;&lt;/action&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;

注意：再manifest中注册时action的name应与<span class="type">Intent</span> intent_BroaadCast = <span class="keyword">new</span>         <span class="type">Intent</span>(<span class="string">"Intent_1112"</span>);中的name保持一致。
</code></pre><p> (2) 隐式调用并传递Extra附加数据与动态广播的使用</p>
<pre><code> 首先，新建一个<span class="type">BroadCastReceiver</span>类

 <span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.<span class="type">BroadcastReceiver</span>;
<span class="keyword">import</span> android.content.<span class="type">Context</span>;
<span class="keyword">import</span> android.content.<span class="type">Intent</span>;
<span class="keyword">import</span> android.widget.<span class="type">Toast</span>;

<span class="comment">/**
 * Created by canglangwenyue on 15-3-5.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">MyBroadCast</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BroadcastReceiver</span> {</span>
    <span class="annotation">@Override</span>
    public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) {

                                                    <span class="type">Toast</span>.makeText(context,intent.getExtras().getString(<span class="string">"StringTest"</span>),
                                                    <span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>
).show();

    }
}

其次，再<span class="type">Activity</span>的onCreate中动态添加<span class="type">IntentFilter</span>，并注册<span class="type">BroadCastReceiver</span>；并在
onStop中取消该<span class="type">BroadCastReceiver</span>。

<span class="type">IntentFilter</span> filter = <span class="keyword">new</span> <span class="type">IntentFilter</span>();
<span class="keyword">private</span> <span class="type">MyBroadCast</span> broadCast = <span class="keyword">new</span> <span class="type">MyBroadCast</span>();

<span class="annotation">@Override</span>
<span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(<span class="type">R</span>.layout.activity_main);

    filter.addAction(<span class="string">"MyBroadCast"</span>);
    registerReceiver(broadCast, filter);

}

 <span class="annotation">@Override</span>
<span class="keyword">protected</span> void onStop() {
    unregisterReceiver(broadCast);
    <span class="keyword">super</span>.onStop();
}

使用该类型<span class="type">Intent</span>的代码：

  <span class="type">Intent</span> intent_ActiveBroaadCast = <span class="keyword">new</span> <span class="type">Intent</span>();
intent_ActiveBroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"阿哈"</span>);
intent_ActiveBroaadCast.setAction(<span class="string">"MyBroadCast"</span>);
<span class="type">MainActivity</span>.<span class="keyword">this</span>.sendBroadcast(intent_ActiveBroaadCast);
</code></pre><p> (3) 不使用广播的Intent</p>
<pre><code> 除了广播来触发<span class="type">Intent</span>的<span class="keyword">Action</span>外，我们还可以使用startActivity()方法来实现相同功能。

     <span class="keyword">public</span> void ButtonClick4(View view) {

    /**
     * 注意：
     * 此处因为有动态声明的BroadCastReceiver，所以运行改方法后程序会奔溃，但是此处因为时范        例，便于对比，所以我并没有新建project
     */

    <span class="type">Intent</span> intent_ActiveBroaadCast = new <span class="type">Intent</span>(<span class="string">"myTest111"</span>);
    intent_ActiveBroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"德玛西亚"</span>);
    MainActivity.this.startActivity(intent_ActiveBroaadCast);
}      

   然后我们必须在该<span class="type">intent</span>想要启动的实现组件中添加IntentFilter来截获，否则就无法匹配到实现组件。

   &lt;activity
        android:<span class="keyword">name</span>=<span class="string">".Activity2"</span>
        android:label=<span class="string">"@string/title_activity_activity2"</span> &gt;
        &lt;<span class="type">intent</span>-filter&gt;
            &lt;<span class="keyword">action</span> android:<span class="keyword">name</span>=<span class="string">"myTest111"</span>&gt;&lt;/<span class="keyword">action</span>&gt;
            &lt;category android:<span class="keyword">name</span>=<span class="string">"android.intent.category.DEFAULT"</span>&gt;&lt;/    category&gt;
        &lt;/<span class="type">intent</span>-filter&gt;
    &lt;/activity&gt; 
需要注意的是：首先，<span class="keyword">action</span> <span class="keyword">name</span>应该保持一致；其次，必须声明
&lt;categoryandroid:<span class="keyword">name</span>=<span class="string">"android.intent.category.DEFAULT"</span>&gt;&lt;/category&gt;，因为，我们在
使用<span class="type">intent</span>时并没有指定category，所以，系统默认添加了<span class="keyword">DEFAULT</span>，故如果不在&lt;<span class="type">intent</span>-filter&gt;进
行声明，则无法匹配到Activity。
</code></pre><p> (4) 使用系统自带的一些标准Action，这里只列举一二：</p>
<pre><code> 获取联系人列表

    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"content://contacts"</span>);
    Intent pickContactIntent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, uri);
      pickContactIntent.setType(ContactsContract.CommonDataKinds.
      Phone.CONTENT_TYPE); <span class="comment">//         Show user only contacts w/ phone numbers</span>
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);  

拨打电话

    <span class="built_in">Uri</span> number = <span class="built_in">Uri</span>.parse(<span class="string">"tel:187008*****"</span>);
    Intent callIntent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL, number);

    startActivity(callIntent);
</code></pre><p>四. Intent 传输数据<br>    android 界面组件间通过要通过Intent来实现，Intent传递数据的方式有两种</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/03/04/android-intent-机制/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2015/03/04/android-intent-机制/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/03/04/android-intent-机制/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-28T09:20:10.000Z"><a href="/2014/12/28/关于大学生创业之我见/">周日, 12月 28 2014, 5:20:10 下午</a></time>

  
    <h1 class="title"><a href="/2014/12/28/关于大学生创业之我见/">关于大学生创业之我见</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/点滴/">点滴</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>时间，对于有限生命的个体而言，永远是个无法结束的话题。从上大学到现在，环境变了，接触到的事物变了，认识的人也不一样了，交际圈更是发生了巨大的变化，心境也是发生了很大变化。自古英雄出少年，昨日凌云壮志仍在我心，初心未改，然，路在何方？</p>
<p>一直以来，在我心中，萦绕着一个问题，我以后一定要自己创业，成就一片属于自己的天空。最近偶有所感，权当记录，以后自有我的人生来印证！</p>
<pre><code>IT相关行业大学上究竟如何才能做好创业的准备，创业之路又在何方？
</code></pre><p>当你的能力慢慢提升了，你的事业自然就变宽阔了，思考的也就不一样了。现在我觉得IT相关行业的大学生其实相比其他行业，或许更具创业优势。当然这里就仁者见仁，智者见智了。因为，他们自身有技术支持，而且创业成本很低，初期有两三个人即可。所以，很多IT公司都可以从车库起家，但是这种情况放在其他行业便不太可能了。</p>
<p>所以，IT行业学生的又是是显而易见的，但是，他们也有自己的不足，那便是交际圈或者说社交能力，经常是这个原因限制了程序员的发展，更是扼杀了创业的可能性。</p>
<p>就目前的我看来，程序员创业做好三点，便足以活得出奇的成功。</p>
<pre><code>1.强悍而又全面面的技术；

2.高质量的社交圈；

3.对于机会的把握能力和勇于冒险的精神。
</code></pre><p>就这三点，我粗浅的说一下自己的认知吧。</p>
<p>首先，对于第一点，有句古话“苦心人,天不负，卧薪尝胆，三千越甲可吞吴；有志者，事竟成，破釜沉舟，百二秦关终属楚。”坚持，专注，真正的专注，那么你必然会在某一领域独领风骚的。而至于全面，有时候就需要借助来自第二点的力量了。</p>
<p>其次，对于第二点，看看马云周围的人那一个不是富豪？？所以，好的环境会对人有积极的影响，除此之外，有时候你会因此而得贵人相助，甚至指点一下，也将是莫大的收获。</p>
<p>最后，对于第三点。就要靠自己对机会的发觉，以及把握能力了，还有敢不敢拿着自己的身家性命赌一把的豪气。</p>
<p>至此，稀里糊涂，写了这些。我想以后我看到回想起以前的懵懂时光的，哈哈。</p>
<p>是七尺男儿，生能舍己，做千秋雄鬼，死不还家。<br>我为青帝日，桃花一处开。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/28/关于大学生创业之我见/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/28/关于大学生创业之我见/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/28/关于大学生创业之我见/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-08T12:40:48.000Z"><a href="/2014/12/08/android-notification完全解析/">周一, 12月 8 2014, 8:40:48 晚上</a></time>

  
    <h1 class="title"><a href="/2014/12/08/android-notification完全解析/">android notification完全解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>Notifications in Android 4.4 and Lower</p>
<p>notification是很重要的部分，它与service，BroadcastReceiver，Intent等密切相关，很好地使用notification可以使你的app的活跃度相对于没有notification 的app大增。</p>
<p>很明显这篇文章将详细的介绍4.4及以下的notification。至于，android 5.0的相关特性，我计划在假期里开一个特辑来写。下载就当是回顾知识了。毕竟，温故而知新嘛，哈哈。</p>
<pre><code>The notification <span class="keyword">system</span> allows your app <span class="built_in">to</span> keep <span class="operator">the</span> user informed about events,
 such <span class="keyword">as</span> <span class="built_in">new</span> chat messages <span class="operator">or</span> <span class="operator">a</span> calendar event. Think <span class="operator">of</span> notifications <span class="keyword">as</span> <span class="operator">a</span> 
 news channel that alerts <span class="operator">the</span> user <span class="built_in">to</span> important events <span class="keyword">as</span> they happen <span class="operator">or</span> <span class="operator">a</span> <span class="built_in">log</span> 
 that chronicles events <span class="keyword">while</span> <span class="operator">the</span> user is <span class="operator">not</span> paying attention.
</code></pre><p>notification使得你的app可以告知用户app中的事件，例如一条新的message或者一个日历事件。可以认为notification是一个新闻渠道，它用来在用户不注意到的时候来通知用户一些重要事件。</p>
<p>Anatomy of a notification</p>
<pre><code>Base Layout

At <span class="operator">a</span> minimum, all notifications consist <span class="operator">of</span> <span class="operator">a</span> base layout, including:

<span class="operator">the</span> sending application<span class="string">'s notification icon or the sender'</span>s photo
<span class="operator">a</span> notification title <span class="operator">and</span> message
<span class="operator">a</span> timestamp
<span class="operator">a</span> secondary icon <span class="built_in">to</span> identify <span class="operator">the</span> sending application when <span class="operator">the</span> sender<span class="string">'s image is     shown for the main icon</span>
</code></pre><p>notification的基本布局</p>
<p>最低限度，所有的notifications 都由基本布局构成，包括：</p>
<p>发送notification的application的icon或者发送者的image。<br>notification的title和message。<br>时间戳<br>当main icon用来显示sender’s image时 Secondary icon用来显示发送application的icon。</p>
<pre><code>Expanded layouts

You have the option to provide more event detail. You can <span class="operator"><span class="keyword">use</span> this <span class="keyword">to</span> <span class="keyword">show</span> the 
<span class="keyword">first</span> few <span class="keyword">lines</span> <span class="keyword">of</span> a message <span class="keyword">or</span> <span class="keyword">show</span> a larger image preview. This provides the 
<span class="keyword">user</span> <span class="keyword">with</span> additional context, <span class="keyword">and</span> - <span class="keyword">in</span> <span class="keyword">some</span> cases - may allow the <span class="keyword">user</span> <span class="keyword">to</span> <span class="keyword">read</span> 
a message <span class="keyword">in</span> its entirety. The <span class="keyword">user</span> can pinch-zoom <span class="keyword">or</span> two-finger glide <span class="keyword">in</span> <span class="keyword">order</span> 
<span class="keyword">to</span> toggle <span class="keyword">between</span> base <span class="keyword">and</span> expanded layouts. <span class="keyword">For</span> single <span class="keyword">event</span> notifications, 
Android provides two expanded layout templates (<span class="built_in">text</span> <span class="keyword">and</span> image) <span class="keyword">for</span> you <span class="keyword">to</span> re-
<span class="keyword">use</span> <span class="keyword">in</span> your application.</span>
</code></pre><p>notification的扩展布局</p>
<p>你可以选择提供事件的更多细节。你可以用它来显示一个message的一些行或者显示一个图片的预览。这些给用户提供了额外的内容，并且，在一些情况下，可以允许用户阅读完整的信息。用户可以通过 pinch-zoom 或者双手指滑动来打开扩展布局。android为单个notification提供了两种扩展布局的方式(image,text)以供你在你的application中使用。</p>
<p><img src="http://cl.ly/image/44191C3N2g3L/notifications_pattern_anatomy.png" alt="Alt text"></p>
<p><img src="http://cl.ly/image/182S1j201G3T/20140224232357359.jpeg" alt="Alt text"></p>
<p><img src="http://cl.ly/image/0R2Q2L1j060v/notifications_pattern_expandable.png" alt="Alt text"></p>
<p>1.notification的title<br>2.发送notification的application的icon或者发送者的image。<br>3.notification的message<br>4.notification的数目显示<br>5.当main icon用来显示sender’s image时 Secondary icon用来显示发送application的icon。<br>6.时间戳，默认为系统发出通知的时间。</p>
<p>Actions</p>
<pre><code>Android supports optional actions <span class="keyword">that</span> are displayed <span class="keyword">at</span> <span class="keyword">the</span> bottom <span class="keyword">of</span> <span class="keyword">the</span> 
notification. With actions, users can handle <span class="keyword">the</span> most common tasks <span class="keyword">for</span> a 
particular notification <span class="keyword">from</span> within <span class="keyword">the</span> notification shade <span class="keyword">without</span> having <span class="keyword">to</span> 
open <span class="keyword">the</span> originating <span class="type">application</span>. This speeds up interaction <span class="keyword">and</span>, <span class="keyword">in</span> 
conjunction <span class="keyword">with</span> <span class="string">"swipe-to-dismiss"</span>, helps users <span class="keyword">to</span> streamline their 
notification triaging experience.

Be judicious <span class="keyword">with</span> how many actions you include <span class="keyword">with</span> a notification. The more 
actions you include, <span class="keyword">the</span> more cognitive complexity you create. Limit yourself 
<span class="keyword">to</span> <span class="keyword">the</span> fewest <span class="type">number</span> <span class="keyword">of</span> actions possible <span class="keyword">by</span> only including <span class="keyword">the</span> most imminently 
important <span class="keyword">and</span> meaningful ones.

Good candidates <span class="keyword">for</span> actions <span class="function_start"><span class="keyword">on</span></span> notifications are actions <span class="keyword">that</span> are:

essential, frequent <span class="keyword">and</span> typical <span class="keyword">for</span> <span class="keyword">the</span> content type you're displaying
<span class="property">time</span>-critical
<span class="keyword">not</span> overlapping <span class="keyword">with</span> neighboring actions
Avoid actions <span class="keyword">that</span> are:

ambiguous，duplicative <span class="keyword">of</span> <span class="keyword">the</span> default action <span class="keyword">of</span> <span class="keyword">the</span> notification (such <span class="keyword">as</span> <span class="string">"Read"</span> <span class="keyword">or</span> <span class="string">"Open"</span>)
</code></pre><p>android支持在notification的地步显示可选的操作。有了这些actions，用户可以处理大多数相同的tasks而无需打开应用。这集快乐交互的速度，并且结合滑动消失使得用户简化其通知处理的经历。</p>
<p>明智的决定在你的notification里面放置的action的数量。如果你包含了更多的action，那么你便增加了交互的复杂性。请选择一个或者两个很重要并且有意义的action。</p>
<p>好的候选action有以下的特点：</p>
<p>.对该通知时重要的，典型的，并且频繁使用的action。<br>.时间紧迫的<br>.不要和相邻的action产生重叠</p>
<p>避免以下操作：</p>
<p>.含糊不清地<br>.和点击notification的action重复的(such as “Read” or “Open”)</p>
<p>Design guidelines</p>
<p>.个性化<br>.导航到正确的地方<br>.正确的设置通知的优先级</p>
<p>主要看一下优先级的设置吧，其他的解释大家可以参考官网。<br>用方法setPriority(int pri)来指定优先级</p>
<p><img src="http://cl.ly/image/2Y2f122Y2r0E/notifications_pattern_priority.png" alt="Alt text"></p>
<p>对应的属性如下：</p>
<p>Notification.PRIORITY_DEFAULT(优先级为0)<br>Notification.PRIORITY_HIGH<br>Notification.PRIORITY_LOW<br>Notification.PRIORITY_MAX(优先级为2)<br>Notification.PRIORITY_MIN(优先级为-2)</p>
<p>现在，我们来看一下，如何实现一个notification。估计大家现在最常用的做法是下面这种：</p>
<pre><code>Notification notification = <span class="keyword">new</span> Notification(R.drawable.ic_launcher, 
getText(R.<span class="built_in">string</span>.app_name),
           System.currentTimeMillis());

   Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.<span class="keyword">class</span>);
   PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, 
   notificationIntent, <span class="number">0</span>);
   notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.<span class="built_in">string</span>.hello_world),
           getText(R.<span class="built_in">string</span>.hello_world), pendingIntent);
   startForeground(<span class="number">1</span>, notification);
</code></pre><p>这是在service里面启动一个notification，但是大家一定记住这种方法已经过时了，也就是说Google官方已经不提倡使用这种方法来启动一个notification了。官方推荐使用V4包下NotificationCompat.Builder，这样，我们便可以设置各种属性。</p>
<p>好了，现在我们具体来看一下，Notification的具体实现。</p>
<p>1.创建一个简单的notification。</p>
<p><img src="http://cl.ly/image/182S1j201G3T/20140224232357359.jpeg" alt="Alt text"></p>
<pre><code>Required notification contents
notification必须要包含的内容

A Notification <span class="tag">object</span> must contain the following:
一个notification必须包含下面的属性：

A small <span class="attribute">icon</span>, set by <span class="function"><span class="title">setSmallIcon</span><span class="params">()</span></span>
一个small <span class="attribute">icon</span>，用<span class="function"><span class="title">setSmallIcon</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">2</span>号区域

A title, set by <span class="function"><span class="title">setContentTitle</span><span class="params">()</span></span>
一个title，用<span class="function"><span class="title">setContentTitle</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">1</span>号区域

Detail text, set by <span class="function"><span class="title">setContentText</span><span class="params">()</span></span>
详细文本，用<span class="function"><span class="title">setContentText</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">3</span>号区域
</code></pre><p>这三个是必须设置的，至于其他的扩展则是需求而定。代码如下：</p>
<pre><code> <span class="keyword">private</span> NotificationManager manager;

NotificationCompat.Builder notifyBuilder;

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    <span class="comment">/*实例化NotificationManager以获取系统服务*/</span>
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

}

<span class="javadoc">/**
 * 显示最简单的通知，以下method中的三个set方法是必须设置的
 *
 *<span class="javadoctag"> @param</span> view
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">simNotification</span><span class="params">(View view)</span> </span>{

    Toast.makeText(<span class="keyword">this</span>, <span class="string">"hha"</span>, Toast.LENGTH_LONG).show();

    notifyBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)
            <span class="comment">/*设置small icon*/</span>
            .setSmallIcon(R.drawable.ic_launcher)
            <span class="comment">/*设置title*/</span>
            .setContentTitle(<span class="string">"通知"</span>)
            <span class="comment">/*设置详细文本*/</span>
            .setContentText(<span class="string">"Hello world"</span>);
    manager.notify(<span class="number">100</span>, notifyBuilder.build());
}
</code></pre><p>代码里的注释已经很详细了，simNotification绑定到了一个Button。这样，我们已经实现了最简单的notification。</p>
<p>2.创建一个点击跳转到其它Activity的Notification。</p>
<pre><code> /<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 点击跳转到指定Activity
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param view</span>
 <span class="keyword">*</span>/
public void largePicture(View view) {
     /<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    //点击的意图ACTION是跳转到Intent
    Intent resultIntent = new Intent(this, MainActivity.class);
    resultIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
    notifyBuilder = new NotificationCompat.Builder(this)
            /<span class="keyword">*</span>设置large icon<span class="keyword">*</span>/
            .setLargeIcon(bitmap)
             /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
            .setSmallIcon(R.drawable.ic_launcher)
            /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
            .setContentTitle(<span class="string">"通知"</span>)
            /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
            .setContentText(<span class="string">"Hello world"</span>)
             /<span class="keyword">*</span>设置发出通知的时间为发出通知时的系统时间<span class="keyword">*</span>/
            .setWhen(System.currentTimeMillis())
             /<span class="keyword">*</span>设置发出通知时在status bar进行提醒<span class="keyword">*</span>/
            .setTicker(<span class="string">"来自问月的祝福"</span>)
            /<span class="keyword">*</span>setOngoing(boolean)设为true,notification将无法通过左右滑动的方式清除
            <span class="keyword">*</span> 可用于添加常驻通知，必须调用cancle方法来清除
            <span class="keyword">*</span>/
            .setOngoing(true)
             /<span class="keyword">*</span>设置点击后通知消失<span class="keyword">*</span>/
            .setAutoCancel(true)
             /<span class="keyword">*</span>设置通知数量的显示类似于QQ那种，用于同志的合并<span class="keyword">*</span>/
            .setNumber(2)
             /<span class="keyword">*</span>点击跳转到MainActivity<span class="keyword">*</span>/
            .setContentIntent(pendingIntent);

    manager.notify(121, notifyBuilder.build());
}
</code></pre><p>代码里的注释都很详细，加上前面的介绍相信大家都能理解了。</p>
<p>3.创建一个显示bitmap的notification，类似于屏幕截图的显示效果</p>
<p><img src="http://cl.ly/image/1Q1s2Q012m1O/big_picture_notification.png" alt="Alt text"></p>
<p> /**</p>
<pre><code> <span class="keyword">*</span> 类似于系统截图的效果
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param view</span>
 <span class="keyword">*</span>/
public void comNotification(View view) {

    /<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    /<span class="keyword">*</span>获取bitmap<span class="keyword">*</span>/
    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
    notifyBuilder = new NotificationCompat.Builder(this)
             /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
            .setSmallIcon(R.drawable.ic_launcher)
            /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
            .setContentTitle(<span class="string">"通知"</span>)
            /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
            .setContentText(<span class="string">"Hello world"</span>)
            .setWhen(System.currentTimeMillis())
            .setOngoing(true)
            .setNumber(2);

    NotificationCompat.BigPictureStyle bigPictureStyle = new NotificationCompat.BigPictureStyle();
    bigPictureStyle.bigPicture(bitmap);
    notifyBuilder.setStyle(bigPictureStyle);

    manager.notify(121, notifyBuilder.build());
}
</code></pre><p>这里唯一需要注意的是加载图片最好不要在UI线程进行(这里只是为了演示)。</p>
<p>4.创建一个类似于日历事件的notification，并与Service进行交互。</p>
<p><img src="http://cl.ly/image/2c3p2b3C2o0x/add_notification.png" alt="Alt text"></p>
<pre><code> <span class="comment">/**
 * 创建一个类似于日历事件的notification
 * @param view
 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_action</span><span class="params">(View view)</span> </span>{

    myIntent = <span class="keyword">new</span> Intent(getApplicationContext(), MyIntentService.<span class="keyword">class</span>);

    myIntent.putExtra(myConstants.EXTRA_MESSAGE, <span class="string">" 来自问月的祝福"</span>);
    myIntent.setAction(myConstants.ACTION_PING);
    myIntent.putExtra(myConstants.EXTRA_TIMER, <span class="number">1000</span>);
    startService(myIntent);

}
</code></pre><p>IntentService代码如下，之后在需要时可以在此扩展IntentService，这里注意一下IntentService类的构造器的重载，super里面是你的路径名。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.test;

<span class="keyword">import</span> android.app.IntentService;
<span class="keyword">import</span> android.app.Notification;
<span class="keyword">import</span> android.app.NotificationManager;
<span class="keyword">import</span> android.app.PendingIntent;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v4.app.NotificationCompat;
<span class="keyword">import</span> android.util.Log;

<span class="javadoc">/**
 * Created by canglangwenyue on 14-12-9.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>{

<span class="keyword">private</span> NotificationManager manager;
<span class="keyword">private</span> String message;
<span class="keyword">private</span> <span class="keyword">int</span> mMills;
NotificationCompat.Builder builder;

<span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>{
    <span class="comment">// The super call is required. The background thread that IntentService</span>
    <span class="comment">// starts is labeled with the string argument you pass.</span>
    <span class="keyword">super</span>(<span class="string">"me.androiddemo.canglangwenyuet.test"</span>);
}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>{

    message = intent.getStringExtra(myConstants.EXTRA_MESSAGE);

    mMills = intent.getIntExtra(myConstants.EXTRA_TIMER, myConstants.DEFAULT_TIMER_DURATION);

    NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    String action = intent.getAction();
    issueNotification(intent,message);

    <span class="keyword">if</span> (action.equals(myConstants.ACTION_PING)) {
        issueNotification(intent,message);
    }<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(action.equals(myConstants.ACTION_SNOOZE)</span>) </span>{
        notificationManager.cancel(myConstants.NOTIFICATION_ID);
        issueNotification(intent,<span class="string">""</span>);
    }<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(action.equals(myConstants.ACTION_DISMISS)</span>) </span>{
        notificationManager.cancel(myConstants.NOTIFICATION_ID);
    }


}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">issueNotification</span><span class="params">(Intent intent, String msg)</span> </span>{
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    Intent dissmissItent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);
    dissmissItent.setAction(myConstants.ACTION_DISMISS);
    PendingIntent disIntent = PendingIntent.getService(<span class="keyword">this</span>,<span class="number">0</span>,dissmissItent,<span class="number">0</span>);

    Intent snoozeIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);
    snoozeIntent.setAction(myConstants.ACTION_SNOOZE);
    PendingIntent snoopIntent = PendingIntent.getService(<span class="keyword">this</span>,<span class="number">0</span>,snoozeIntent,<span class="number">0</span>);

    builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)
            .setSmallIcon(R.drawable.ic_launcher)
            .setContentTitle(<span class="string">"Information"</span>)
            .setContentText(<span class="string">"lalallalala"</span>)
            .setDefaults(Notification.DEFAULT_ALL)
            .setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle().bigText(msg))
            .addAction(R.drawable.ic_launcher, <span class="string">"Dismiss"</span>, disIntent)
            .addAction(R.drawable.ic_launcher,<span class="string">"snooze"</span>,snoopIntent);


    Intent resultIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity2.class);
    resultIntent.putExtra(myConstants.EXTRA_MESSAGE,msg);
    resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);


    PendingIntent resultPendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,resultIntent,PendingIntent.FLAG_UPDATE_CURRENT);

    builder.setContentIntent(resultPendingIntent);
    <span class="comment">//        manager.notify(myConstants.NOTIFICATION_ID,builder.build());</span>
    startTimer(mMills);



}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startTimer</span><span class="params">(<span class="keyword">int</span> mMills)</span> </span>{
    <span class="keyword">try</span> {

        Thread.sleep(mMills);

    }<span class="keyword">catch</span> (Exception e) {
        Log.d(myConstants.DEBUG_TAG, <span class="string">"ERROR"</span>);
    }
    issueNotification(builder);
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">issueNotification</span><span class="params">(NotificationCompat.Builder builder)</span> </span>{
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    manager.notify(myConstants.NOTIFICATION_ID,builder.build());
}
}
</code></pre><p>这里只是实现了一个简单的Timer。参考一下就好。</p>
<p>5.创建一个自定义的notification，只要通过RemoteViews来获取你的XML布局文件，并通过.setContent(remoteViews)就好，大家只需要对比不同之处。</p>
<p><img src="http://cl.ly/image/1x2d1m2a0C2t/ustom_notification.png" alt="Alt text"></p>
<pre><code> /**
 * 自定义notification样式
 *
 * @param view
 */
<span class="component">public void Cus_Notification(View view) {

    Toast<span class="string">.makeText(MainActivity.this</span>, "AHa", Toast<span class="string">.LENGTH_LONG).show()</span>;
    /*实例化NotificationManager以获取系统服务*/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    RemoteViews remoteViews = new RemoteViews(getPackageName(), R<span class="string">.layout.customnotification)</span>;

    remoteViews<span class="string">.setImageViewResource(R.id.imageView</span>, R<span class="string">.drawable.psb)</span>;
    remoteViews<span class="string">.setTextViewText(R.id.textView</span>, "Your Haven");

    remoteViews<span class="string">.setTextViewText(R.id.textView2</span>, "YUI");
    remoteViews<span class="string">.setTextViewText(R.id.textView3</span>, "豆瓣－FNM －我的红心 MHZ");

    remoteViews<span class="string">.setViewVisibility(R.id.my_large_button</span>, View<span class="string">.VISIBLE)</span>;
    notifyBuilder = new NotificationCompat<span class="string">.Builder(this)</span>
            <span class="string">.setContent(remoteViews)</span>
            <span class="string">.setContentIntent(getDefalutIntent(Notification.FLAG_AUTO_CANCEL))</span>
             /*设置small icon*/
            <span class="string">.setSmallIcon(R.drawable.ic_launcher)</span>
            /*设置title*/
            <span class="string">.setContentTitle("通知")</span>
            /*设置详细文本*/
            <span class="string">.setTicker("Your</span> Haven")
            <span class="string">.setContentText("Hello</span> world")
            <span class="string">.setWhen(System.currentTimeMillis())</span>
            <span class="string">.setPriority(Notification.PRIORITY_DEFAULT)//</span> 设置该通知优先级
            <span class="string">.setOngoing(true)</span>;

    Notification noty = notifyBuilder<span class="string">.build()</span>;
    noty<span class="string">.contentView</span> = remoteViews;
    manager<span class="string">.notify(313</span>, noty);

}</span>
</code></pre><p>这里只是添加了一个ImageView和三个TextView，大家可以进一步扩充，例如添加ImageButton，并通过BroadcastReceiver来监听。</p>
<p>6.最后在写一个带进度条指示器的notification吧，到了这里大家应该理解什么叫求同存异了吧，哈哈。至于其它的notification，例如FullScreen下的notification或者LockScreen的notification等，都是换汤不换药，大家只要按需设置相应的属性就好，具体可以查询官方文档。</p>
<p><img src="http://cl.ly/image/0B0D2h0o001j/process_notification.png" alt="Alt text"></p>
<pre><code><span class="javadoc">/**
 * 有进度条的notification
 *<span class="javadoctag"> @param</span> view
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Pro_Notification</span><span class="params">(View view)</span> </span>{

    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    notifyBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);
    notifyBuilder.setContentTitle(<span class="string">"Picture Download"</span>)
            .setContentText(<span class="string">"Download in progress"</span>)
            .setOngoing(<span class="keyword">true</span>)
            .setSmallIcon(R.drawable.ic_launcher);
<span class="comment">// Start a lengthy operation in a background thread</span>
    <span class="keyword">new</span> Thread(
            <span class="keyword">new</span> Runnable() {
                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">int</span> incr;
                    <span class="comment">// Do the "lengthy" operation 20 times</span>
                    <span class="keyword">for</span> (incr = <span class="number">0</span>; incr &lt;= <span class="number">100</span>; incr += <span class="number">5</span>) {
                        <span class="comment">// Sets the progress indicator to a max value, the</span>
                        <span class="comment">// current completion percentage, and "determinate"</span>
                        <span class="comment">// state</span>
                        notifyBuilder.setProgress(<span class="number">100</span>, incr, <span class="keyword">false</span>);
                        <span class="comment">// Displays the progress bar for the first time.</span>
                        manager.notify(<span class="number">0</span>, notifyBuilder.build());
                        <span class="comment">// Sleeps the thread, simulating an operation</span>
                        <span class="comment">// that takes time</span>
                        <span class="keyword">try</span> {
                            <span class="comment">// Sleep for 5 seconds</span>
                            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            Log.d(<span class="string">"NOTIFICATION"</span>, <span class="string">"sleep failure"</span>);
                        }
                    }
                    <span class="comment">// When the loop is finished, updates the notification</span>
                    notifyBuilder.setContentText(<span class="string">"Download complete"</span>)
                            <span class="comment">// Removes the progress bar</span>
                            .setProgress(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);
                    manager.notify(<span class="number">213</span>, notifyBuilder.build());
                }
            }
<span class="comment">// Starts the thread by calling the run() method in its Runnable</span>
    ).start();

}
</code></pre><p>大概解释一下，就是在一个异步线程里面每隔5秒使notification的process增加5，循环结束后，在重新添加一个notification来显示下载完成。至于进度还有其他方式设置，这里就不一一介绍了，实际使用时可以传入具体的下载进度。</p>
<p>好了，感觉已经写了好多了，最后来总结一下notification的使用吧。<br>(一)通过以下几个步骤就可以获得一个notification的实现：</p>
<p>1.获取NotificationManager实例，即获得状态通知栏管理权；</p>
<pre><code>/<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
   manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
</code></pre><p>2.实例化notification的constructor</p>
<pre><code>notifyBuilder = new NotificationCompat.<span class="function"><span class="title">Builder</span><span class="params">(this)</span></span>
</code></pre><p>3.对notifyBuilder设置各种属性</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
            <span class="keyword">*</span> 前三个属性必须设置
            <span class="keyword">*</span>/
           /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
           .setSmallIcon(R.drawable.ic_launcher)
           /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
           .setContentTitle(<span class="string">"通知"</span>)
           /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
           .setContentText(<span class="string">"Hello world"</span>)
            /<span class="keyword">*</span>设置发出通知的时间为发出通知时的系统时间<span class="keyword">*</span>/
           .setWhen(System.currentTimeMillis())
            /<span class="keyword">*</span>设置发出通知时在status bar进行提醒<span class="keyword">*</span>/
           .setTicker(<span class="string">"来自问月的祝福"</span>)
            /<span class="keyword">*</span>设置点击后通知消失<span class="keyword">*</span>/
           .setAutoCancel(true)
                   /<span class="keyword">*</span><span class="keyword">*</span>
                    <span class="keyword">*</span> 设置
                    notification的默认效果有以下几种
                    Notification.DEFAULT_ALL：铃声、闪光、震动均系统默认。
                    Notification.DEFAULT_SOUND：系统默认铃声。
                    Notification.DEFAULT_VIBRATE：系统默认震动。
                    Notification.DEFAULT_LIGHTS：系统默认闪光。
                    <span class="keyword">*</span>/
           .setDefaults(Notification.DEFAULT_VIBRATE)
            /<span class="keyword">*</span>setOngoing(boolean)设为true,notification将无法通过左右滑动的方式清除
           <span class="keyword">*</span> 可用于添加常驻通知，必须调用cancle方法来清除
           <span class="keyword">*</span>/
           .setOngoing(true)
            /<span class="keyword">*</span>设置通知数量的显示类似于QQ那种，用于同志的合并<span class="keyword">*</span>/
           .setNumber(2);
</code></pre><p> 4.显示notification</p>
<pre><code>manager.notify(<span class="number">100</span>, notifyBuilder.build<span class="literal">()</span>);
</code></pre><p> (二)一些常用的属性函数</p>
<p> .setDefaults(int defaults)<br>     用于向通知添加声音、闪灯和振动效果的最简单、使用默认（defaults）属性，具体在上述代码中有写到。</p>
<p> .setVibrate(long[] pattern)<br>     用于设置是否开启震动,true为开启</p>
<p> .setSound(Uri sound)<br>     用于设置通知铃声</p>
<p> .setPriority(int pri)<br>     用于设置优先级，同样之前有详细讲解</p>
<p> .setOngoing(boolean ongoing)<br>     设置为true则为常驻通知栏的通知类似于墨迹天气那种的效果。</p>
<p> setProgress(int max, int progress,boolean indeterminate)<br>     用于设置进度的notification中<br>嗯，今天就写这些吧，最后附上demo的下载地址。<a href="http://download.csdn.net/detail/u010835702/8241469" target="_blank" rel="external">点此下载</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/08/android-notification完全解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/08/android-notification完全解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/08/android-notification完全解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-07T02:31:34.000Z"><a href="/2014/12/07/android-service完全解析/">周日, 12月 7 2014, 10:31:34 上午</a></time>

  
    <h1 class="title"><a href="/2014/12/07/android-service完全解析/">android Service完全解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>老规矩，先看官方文档是怎么说的。</p>
<pre><code>A Service is <span class="operator">an</span> application component that can perform <span class="keyword">long</span>-running operations <span class="operator">in</span>
 <span class="operator">the</span> background <span class="operator">and</span> does <span class="operator">not</span> provide <span class="operator">a</span> user interface. Another application 
 component can <span class="built_in">start</span> <span class="operator">a</span> service <span class="operator">and</span> <span class="keyword">it</span> will continue <span class="built_in">to</span> run <span class="operator">in</span> <span class="operator">the</span> background even 
 <span class="keyword">if</span> <span class="operator">the</span> user switches <span class="built_in">to</span> another application. Additionally, <span class="operator">a</span> component can bind
  <span class="built_in">to</span> <span class="operator">a</span> service <span class="built_in">to</span> interact <span class="operator">with</span> <span class="keyword">it</span> <span class="operator">and</span> even perform interprocess communication 
  (IPC). For example, <span class="operator">a</span> service might handle network transactions, play music, 
  perform <span class="built_in">file</span> I/O, <span class="operator">or</span> interact <span class="operator">with</span> <span class="operator">a</span> content provider, all <span class="built_in">from</span> <span class="operator">the</span> background.
</code></pre><p>以我的理解呢，大概就是说：</p>
<p>service是一个没有用户界面并且运行在后台以执行长时间耗时操作的app application组件。其它的application 组件能够启动service，而且service将一直执行下去，即使用户从当前service所属的application切换到了其它的application。另外，一个组件可以绑定到一个服务来和它交互，甚至是进程间通信(IPC机制)。for example，一个服务可能会处理网络操作，播放音乐，处理文件的IO操作，或者与content provider交互，所有的操作都是在后台完成的。</p>
<p>A service can essentially take two forms:</p>
<pre><code><span class="number">1.</span>started

A service is <span class="string">"started"</span> when <span class="operator">an</span> application component (such <span class="keyword">as</span> <span class="operator">an</span> activity) starts
<span class="keyword">it</span> <span class="keyword">by</span> calling startService(). Once started, <span class="operator">a</span> service can run <span class="operator">in</span> <span class="operator">the</span> background 
indefinitely, even <span class="keyword">if</span> <span class="operator">the</span> component that started <span class="keyword">it</span> is destroyed. Usually, <span class="operator">a</span> 
started service performs <span class="operator">a</span> single operation <span class="operator">and</span> does <span class="operator">not</span> <span class="constant">return</span> <span class="operator">a</span> <span class="built_in">result</span> <span class="built_in">to</span> <span class="operator">the</span>
 caller. For example, <span class="keyword">it</span> might download <span class="operator">or</span> upload <span class="operator">a</span> <span class="built_in">file</span> over <span class="operator">the</span> network. When
  <span class="operator">the</span> operation is done, <span class="operator">the</span> service should <span class="built_in">stop</span> itself.

<span class="number">2.</span>Bound

A service is <span class="string">"bound"</span> when <span class="operator">an</span> application component binds <span class="built_in">to</span> <span class="keyword">it</span> <span class="keyword">by</span> calling 
bindService(). A bound service offers <span class="operator">a</span> client-server interface that allows 
components <span class="built_in">to</span> interact <span class="operator">with</span> <span class="operator">the</span> service, <span class="built_in">send</span> requests, <span class="built_in">get</span> results, <span class="operator">and</span> even <span class="built_in">do</span>
 so across processes <span class="operator">with</span> interprocess communication (IPC). A bound service runs 
 only <span class="keyword">as</span> <span class="keyword">long</span> <span class="keyword">as</span> another application component is bound <span class="built_in">to</span> <span class="keyword">it</span>. Multiple 
 components can bind <span class="built_in">to</span> <span class="operator">the</span> service <span class="keyword">at</span> once, but when all <span class="operator">of</span> them unbind, <span class="operator">the</span> 
 service is destroyed.
</code></pre><p>1.started<br>    当一个application 组件通过调用start Service()启动service之后service处于“started”形式。一旦service启动，它将在无限的后台运行，即使触发service的组件已经被销毁。通常，一个started的形式的service执行单一操作，并且不返回结果给启动它的组件。for example，它可能从网络下载或者上传文件。当操作结束后，service应该结束掉它自己。<br>2.Bound<br>    当一个application组件通过调用bindService()使一个service处于“bound”形式。一个bound的service提供了一个C/S接口以完成application 组件和这个service的交互，send requests，getresults，甚至通过跨进成调度来通信。一个bound service只有在组件绑定它之后才可以运行。多个组件可以一次性绑定一个service，但是，当它们都取消绑定后，service将被销毁。</p>
<pre><code>Although this documentation generally discusses these two types <span class="keyword">of</span> services 
separately, your service can work both ways—<span class="keyword">it</span> can be started (<span class="keyword">to</span> <span class="command">run</span> 
indefinitely) <span class="keyword">and</span> also allow binding. It's simply a matter <span class="keyword">of</span> whether you 
implement a couple callback methods: onStartCommand() <span class="keyword">to</span> allow components <span class="keyword">to</span> 
start <span class="keyword">it</span> <span class="keyword">and</span> onBind() <span class="keyword">to</span> allow binding.

Regardless <span class="keyword">of</span> whether your <span class="type">application</span> <span class="keyword">is</span> started, bound, <span class="keyword">or</span> both, any 
<span class="type">application</span> component can use <span class="keyword">the</span> service (even <span class="keyword">from</span> a separate <span class="type">application</span>),
 <span class="keyword">in</span> <span class="keyword">the</span> same way <span class="keyword">that</span> any component can use an activity—<span class="keyword">by</span> starting <span class="keyword">it</span> <span class="keyword">with</span> an
  Intent. However, you can declare <span class="keyword">the</span> service <span class="keyword">as</span> private, <span class="keyword">in</span> <span class="keyword">the</span> manifest 
  <span class="type">file</span>, <span class="keyword">and</span> block access <span class="keyword">from</span> other applications. This <span class="keyword">is</span> discussed more <span class="keyword">in</span> <span class="keyword">the</span> 
  section <span class="keyword">about</span> Declaring <span class="keyword">the</span> service <span class="keyword">in</span> <span class="keyword">the</span> manifest.
</code></pre><p>这两段比价简单，只需要注意一下在manifest中声明service为你的application私有就好了。</p>
<pre><code>Caution: A service runs <span class="keyword">in</span> <span class="keyword">the</span> main thread <span class="keyword">of</span> <span class="keyword">its</span> hosting process—<span class="keyword">the</span> service 
<span class="keyword">does</span> <span class="keyword">not</span> create <span class="keyword">its</span> own thread <span class="keyword">and</span> <span class="keyword">does</span> <span class="keyword">not</span> <span class="command">run</span> <span class="keyword">in</span> a separate process (unless 
you specify otherwise). This means <span class="keyword">that</span>, <span class="keyword">if</span> your service <span class="keyword">is</span> going <span class="keyword">to</span> do any CPU 
intensive work <span class="keyword">or</span> blocking operations (such <span class="keyword">as</span> MP3 playback <span class="keyword">or</span> networking), you
 should create a new thread within <span class="keyword">the</span> service <span class="keyword">to</span> do <span class="keyword">that</span> work. By using a 
 separate thread, you will reduce <span class="keyword">the</span> risk <span class="keyword">of</span> Application Not Responding (ANR)
  errors <span class="keyword">and</span> <span class="keyword">the</span> <span class="type">application</span>'s main thread can remain dedicated <span class="keyword">to</span> user 
  interaction <span class="keyword">with</span> your activities.
</code></pre><p>慎重处理：一个service运行在当前进程的主线程中，service不能为自己创建线程也不能在另外的进程运行。这就意味着，如果你的service将要执行一些CPU密集型操作，或者线程阻塞操作(such as MP3 playback or networking),你应该新建一个包含该service的线程来执行此类操作。通过使用另一个线程，你的application将减少了引发ANR错误的可能性，并且你的主线程将保留这来进行与用户的交互活动。</p>
<hr>
<p>延伸阅读 :Should you use a service or a thread?</p>
<pre><code>A service <span class="keyword">is</span> simply a component <span class="keyword">that</span> can <span class="command">run</span> <span class="keyword">in</span> <span class="keyword">the</span> background even when <span class="keyword">the</span> 
user <span class="keyword">is</span> <span class="keyword">not</span> interacting <span class="keyword">with</span> your <span class="type">application</span>. Thus, you should create a 
service only <span class="keyword">if</span> <span class="keyword">that</span> <span class="keyword">is</span> what you need.

If you need <span class="keyword">to</span> perform work outside your main thread, <span class="keyword">but</span> only <span class="keyword">while</span> <span class="keyword">the</span> user 
<span class="keyword">is</span> interacting <span class="keyword">with</span> your <span class="type">application</span>, <span class="keyword">then</span> you should probably instead create a 
new thread <span class="keyword">and</span> <span class="keyword">not</span> a service. For example, <span class="keyword">if</span> you want <span class="keyword">to</span> play <span class="keyword">some</span> music, <span class="keyword">but</span> 
only <span class="keyword">while</span> your activity <span class="keyword">is</span> <span class="property">running</span>, you might create a thread <span class="keyword">in</span> onCreate(), 
start <span class="property">running</span> <span class="keyword">it</span> <span class="keyword">in</span> onStart(), <span class="keyword">then</span> stop <span class="keyword">it</span> <span class="keyword">in</span> onStop(). Also consider using 
AsyncTask <span class="keyword">or</span> HandlerThread, <span class="keyword">instead of</span> <span class="keyword">the</span> traditional Thread <span class="type">class</span>. See <span class="keyword">the</span>
 Processes <span class="keyword">and</span> Threading document <span class="keyword">for</span> more information <span class="keyword">about</span> threads.

Remember <span class="keyword">that</span> <span class="keyword">if</span> you do use a service, <span class="keyword">it</span> still runs <span class="keyword">in</span> your <span class="type">application</span>'s main
 thread <span class="keyword">by</span> default, so you should still create a new thread within <span class="keyword">the</span> service 
 <span class="keyword">if</span> <span class="keyword">it</span> performs intensive <span class="keyword">or</span> blocking operations.
</code></pre><p>有了前面的铺垫，相比此处很容易裂理解吧，贴出来只是为了大家使用thread和service更容易的思考和抉择。</p>
<hr>
<p>好，现在来看一下Service的生命周期：</p>
<p><img src="http://cl.ly/image/2X1O1j2H033l/service_lifecycle.png" alt="Alt text"></p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

 android.app.Service;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.content.res.Configuration;
<span class="keyword">import</span> android.os.IBinder;

<span class="keyword">import</span> java.io.FileDescriptor;
<span class="keyword">import</span> java.io.PrintWriter;

<span class="javadoc">/**
 * Created by canglangwenyue on 12/7/14.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{
<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onCreate();
     Notification notification = <span class="keyword">new</span> Notification(R.drawable.ic_launcher, getText(R.string.app_name),
            System.currentTimeMillis());
    Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);
    notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.hello_world),
            getText(R.string.hello_world), pendingIntent);
    startForeground(<span class="number">1</span>, notification);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>{
    <span class="keyword">super</span>.onStart(intent, startId);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onStartCommand</span><span class="params">(intent, flags, startId)</span></span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onDestroy();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>{
    <span class="keyword">super</span>.onConfigurationChanged(newConfig);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onLowMemory();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>{
    <span class="keyword">super</span>.onTrimMemory(level);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>{
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onUnbind</span><span class="params">(intent)</span></span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>{
    <span class="keyword">super</span>.onRebind(intent);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTaskRemoved</span><span class="params">(Intent rootIntent)</span> </span>{
    <span class="keyword">super</span>.onTaskRemoved(rootIntent);
}

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter writer, String[] args)</span> </span>{
    <span class="keyword">super</span>.dump(fd, writer, args);
}
    }
</code></pre><p>记得在manifest文件里注册service，</p>
<p><img src="http://cl.ly/3y110Y3u3B2O/registerservice.tiff" alt="Alt text"></p>
<p>可以在onCreate()方法中启动一个notification，是你的service显示在通知栏，当然这里只是简单的显示，具体可可以做更多的工作。然后在需要启动service的activity里面用</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(this,MyService.<span class="keyword">class</span>);

startService(<span class="type">intent</span>);
</code></pre><p>来开始一个 service。</p>
<hr>
<p>好了，既然Service已经写到这种程度了，那么我们就再接再厉来看看IntentService吧，并比较一下如何在service与IntentService之间抉择，让大家更好地理解。</p>
<pre><code>Service

This <span class="keyword">is</span> the base <span class="keyword">class</span> <span class="keyword">for</span> all services. <span class="keyword">When</span> you extend this <span class="keyword">class</span>, it<span class="comment">'s </span>
important that you create a <span class="keyword">new</span> thread <span class="keyword">in</span> which <span class="keyword">to</span> <span class="keyword">do</span> all the service<span class="comment">'s work, </span>
because the service uses your application<span class="comment">'s main thread, by default, which </span>
could slow the performance <span class="keyword">of</span> any activity your application <span class="keyword">is</span> running.
IntentService

This <span class="keyword">is</span> a subclass <span class="keyword">of</span> Service that uses a worker thread <span class="keyword">to</span> handle all start 
requests, one at a time. This <span class="keyword">is</span> the best <span class="keyword">option</span> <span class="keyword">if</span> you don<span class="comment">'t require that your </span>
service handle multiple requests simultaneously. All you need <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">is</span> 
implement onHandleIntent(), which receives the intent <span class="keyword">for</span> <span class="keyword">each</span> start request so 
you can <span class="keyword">do</span> the background work.
</code></pre><p>Service </p>
<pre><code>这是所有services的基类。当你extendsService之后，你是在你的application的<span class="keyword">main</span> thread中创建了一个用于执行所有<span class="keyword">service</span><span class="string">'s work的新线程，默认的，这种行为会降低你的activity正在执行的任何activity的性能。</span>
</code></pre><p>IntentService</p>
<pre><code>IntentService是Service类的子类，它用一个工作线程来处理所有的requests，而且一次只能执行一个。如果你不要求你的Service同时执行多个请求，那么IntentService便是最好的选择。你所需要做的只是实现<span class="function"><span class="title">onHandleIntent</span><span class="params">()</span></span>，<span class="function"><span class="title">onHandleIntent</span><span class="params">()</span></span>用来接收每个请求并在后台工作。使用Service使必须另开线程，而使用IntentService则不需要，因为framework默认实现了一个worker thread。IntentService自己维护了一个队列，他会一个接一个的处理request。
</code></pre><p>好了，那么来看一下，官网上IntentService的实现：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">IntentService</span> {</span>

  <span class="comment">/** 
   * A constructor is required, and must call the super IntentService(String)
   * constructor with a name for the worker thread.
   */</span>
  public <span class="type">HelloIntentService</span>() {
      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);
  }

  <span class="comment">/**
   * The IntentService calls this method from the default worker thread with 
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */</span>
  <span class="annotation">@Override</span>
  <span class="keyword">protected</span> void onHandleIntent(<span class="type">Intent</span> intent) {
  <span class="comment">// Normally we would do some work here, like download a file.</span>
  <span class="comment">// For our sample, we just sleep for 5 seconds.</span>
  long endTime = <span class="type">System</span>.currentTimeMillis() + <span class="number">5</span>*<span class="number">1000</span>;
      <span class="keyword">while</span> (<span class="type">System</span>.currentTimeMillis() &lt; endTime) {
          synchronized (<span class="keyword">this</span>) {
              <span class="keyword">try</span> {
                  wait(endTime - <span class="type">System</span>.currentTimeMillis());
              } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
              }
          }
      }
  }
}
</code></pre><p>好了，现在应该是很简单了，有木有。注意IntentService一般和LocalBroadcastManager组合使用，从而使得IntentService将任务执行的任务状态与结果返回给任务的发送方。</p>
<p>官方文档地址：</p>
<p><a href="http://developer.android.com/guide/components/services.html#Basics" target="_blank" rel="external">API Guides</a></p>
<p><a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="external">Reference</a></p>
<p>嗯嗯，就写到这里了。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/07/android-service完全解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/07/android-service完全解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/07/android-service完全解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-05T06:26:01.000Z"><a href="/2014/12/05/javalangcloneable解析/">周五, 12月 5 2014, 2:26:01 下午</a></time>

  
    <h1 class="title"><a href="/2014/12/05/javalangcloneable解析/">java.lang.Cloneable解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/java/">java</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>java.lang<br>Interface Cloneable</p>
<p>All Known Subinterfaces:<br>所有已知的子接口</p>
<pre><code>AclEntry, Attribute, AttributedCharacterIterator, Attributes, CertPathBuilderResult,CertPathParameters, CertPathValidatorResult, CertSelector,
 CertStoreParameters, CharacterIterator, CRLSelector, Descriptor, GSSCredential,
  <span class="keyword">Name</span>
</code></pre><p>public interface Cloneable</p>
<pre><code>A class implements the <span class="type">Cloneable</span> <span class="keyword">interface</span> to indicate to the <span class="type">Object</span>.clone() 
<span class="keyword">method</span> that it <span class="keyword">is</span> legal <span class="keyword">for</span> that <span class="keyword">method</span> to make a field-<span class="keyword">for</span>-field copy <span class="keyword">of</span> 
instances <span class="keyword">of</span> that class.

<span class="type">Invoking</span> <span class="type">Object</span>'s clone <span class="keyword">method</span> on an instance that does <span class="keyword">not</span> implement the 
<span class="type">Cloneable</span> <span class="keyword">interface</span> results <span class="keyword">in</span> the exception <span class="type">CloneNotSupportedException</span> being 
thrown.

<span class="type">By</span> convention, classes that implement this <span class="keyword">interface</span> should override <span class="type">Object</span>.clone
 (which <span class="keyword">is</span> protected) <span class="keyword">with</span> a public <span class="keyword">method</span>. <span class="type">See</span> <span class="type">Object</span>.clone() <span class="keyword">for</span> details on
  overriding this <span class="keyword">method</span>.

<span class="type">Note</span> that this <span class="keyword">interface</span> does <span class="keyword">not</span> contain the clone <span class="keyword">method</span>. <span class="type">Therefore</span>, it <span class="keyword">is</span> <span class="keyword">not</span>
 possible to clone an <span class="keyword">object</span> merely by virtue <span class="keyword">of</span> the fact that it implements this 
 <span class="keyword">interface</span>. <span class="type">Even</span> <span class="keyword">if</span> the clone <span class="keyword">method</span> <span class="keyword">is</span> invoked reflectively, there <span class="keyword">is</span> no 
 guarantee that it will succeed.
</code></pre><p>此类实现了Cloneable interface以表明Object.clone() 方法可以以合法的方式对该class的实例进行复制。</p>
<p>如果调用clone method方法的实例没有implements Cloneable接口，那么会抛出CloneNotSupportedException Exception。</p>
<p>按照习惯，implements了Cloneable接口的classes需要重载Object.clone(它是protected)。</p>
<p>注意，这个interface不包含clone method。因此，某个对象实现了它就clone是不可能的。即使反射调用clone method，也不会保证该调用会成功。</p>
<p>Since:<br>JDK1.0<br>See Also:<br>CloneNotSupportedException, Object.clone()</p>
<hr>
<p>以上直接翻译自java doc，想必已经很清楚了吧。接下来，技改出一个简单的例子，来记录一下。</p>
<pre><code><span class="comment">/**
 * Created by canglangwenyue on 12/5/14.
 */</span>
<span class="keyword">public</span> class Person implements Cloneable {

    <span class="keyword">private</span> <span class="built_in">int</span> id;
    <span class="keyword">private</span> <span class="keyword">String</span> name;

    <span class="keyword">public</span> <span class="keyword">String</span> getName() {
    <span class="keyword">return</span> name;
    }

    <span class="keyword">public</span> <span class="built_in">int</span> getId() {
    <span class="keyword">return</span> id;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> setId(<span class="built_in">int</span> id) {
    <span class="keyword">this</span>.id = id;
    }

        <span class="keyword">public</span> <span class="keyword">void</span> setName(<span class="keyword">String</span> name) {
    <span class="keyword">this</span>.name = name;
        }

    @Override
    <span class="keyword">protected</span> <span class="keyword">Object</span> clone() {

    Person <span class="built_in">copy</span> = <span class="keyword">null</span>;

    <span class="keyword">try</span> {
        <span class="built_in">copy</span> = (Person) <span class="keyword">super</span>.clone();
        <span class="built_in">copy</span>.clone().getClass().getName();

    } <span class="keyword">catch</span> (CloneNotSupportedException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">return</span> <span class="built_in">copy</span>;
    }


        }

        @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> obj) {
    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);
    }

    <span class="comment">/**
     * 引用复制的测试
     */</span>

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> referenceTest() {
    Person person = <span class="keyword">new</span> Person();

    person.setId(<span class="number">1</span>);
    person.setName(<span class="string">"WenYue"</span>);

    Person <span class="built_in">copy</span> = person;

    <span class="keyword">if</span> (<span class="built_in">copy</span>.equals(person))
        System.out.<span class="built_in">println</span>(<span class="string">"引用复制的person和copy是同一个对象"</span>);
    <span class="keyword">else</span>
        System.out.<span class="built_in">println</span>(<span class="string">"引用复制的person和copy不是同一个对象"</span>);

    System.out.<span class="built_in">println</span>(person);
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>);
    System.out.<span class="built_in">println</span>(person.getName());
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>.getName());

        }

    <span class="comment">/**
     * 对于Object的clone的测试方法，并检测出clone实现的是浅拷贝
     */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> cloneTest(){
    Person person = <span class="keyword">new</span> Person();

    person.setId(<span class="number">1</span>);
    person.setName(<span class="string">"WenYue"</span>);

    Person <span class="built_in">copy</span> = <span class="keyword">null</span>;

    <span class="built_in">copy</span> = (Person) person.clone();

    <span class="keyword">if</span> (<span class="built_in">copy</span>.equals(person))
        System.out.<span class="built_in">println</span>(<span class="string">"clone的person和copy是同一个对象"</span>);
    <span class="keyword">else</span>
        System.out.<span class="built_in">println</span>(<span class="string">"clone的person和copy不是同一个对象"</span>);

    System.out.<span class="built_in">println</span>(person);
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>);
    System.out.<span class="built_in">println</span>(person.getName());
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>.getName());

    <span class="keyword">String</span> result = person.getName()==<span class="built_in">copy</span>.getName()?<span class="string">"clone是浅拷贝"</span>:<span class="string">"clone是深拷贝"</span>;
    System.out.<span class="built_in">println</span>(result);
        }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    <span class="comment">/*测试clone*/</span>
    cloneTest();

    <span class="comment">/*测试引用复制*/</span>
    referenceTest();

    }


    }
</code></pre><p>给出main函数的执行结果：</p>
<p><img src="http://cl.ly/1K3b3B1E0G1S/ObjectClone.tiff" alt="Alt text"></p>
<p>好了，现在来解释一下这段测试代码。</p>
<p>可以看到main函数中执行了两个测试方法，cloneTest()和referenceTest();第一个实现了Cloneable interface后的Object进行clone() method的测试；而之所以添加第二个method的原因是将对象的浅拷贝，即clone(java 中默认对象的拷贝是浅拷贝)。，与引用的复制进行对比，便于大家理解。</p>
<pre><code><span class="number">1.</span>从这段代码的执行结果中可以清晰地看到，clone实现的<span class="keyword">copy</span>为<span class="keyword">copy</span>创建了新对象(在内存中的地址不同)，而<span class="keyword">reference</span>的复制，只是把原对象的地址复制给了新对象，所以直行后，person和<span class="keyword">copy</span>指向了相同的地址空间。
</code></pre><p>关于clone默认是浅拷贝的解释</p>
<pre><code><span class="number">2</span>. 首先，由于id是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个<span class="number">4</span>字节的整数值拷贝过来就行。但是name是<span class="type">String</span>类型的，而且name只是一个引用，指向真正的<span class="type">String</span>对象，之所以说clone默认是浅拷贝的原因就是，在clone时clone方法只是把<span class="type">String</span>对象的引用值拷贝给了新的copy对象的name字段；而并非在内存中重新创建一个<span class="type">String</span>对象，并让copy对象的name字段的引用指向它。证明如下：

 <span class="type">String</span> <span class="literal">result</span> = person.getName()==copy.getName()?<span class="string">"clone是浅拷贝"</span>:<span class="string">"clone是深拷贝"</span>;
首先请大家看着行代码，大概意思是若二者在内存中的地址相同，则返回<span class="string">"clone是浅拷贝"</span>，而内存中的地址空间是否相同便可以判断是否是同一个对象。

<span class="number">3</span>.正如前面文档解释的implements了<span class="type">Cloneable</span>接口的classes需要重载<span class="type">Object</span>.clone。
</code></pre><p>这里挖个坑吧，关于深拷贝的仔细研究，我就在之后来填。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/05/javalangcloneable解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/05/javalangcloneable解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/05/javalangcloneable解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-05T01:16:06.000Z"><a href="/2014/12/05/androidosparcelable文档自译/">周五, 12月 5 2014, 9:16:06 上午</a></time>

  
    <h1 class="title"><a href="/2014/12/05/androidosparcelable文档自译/">android.os.Parcelable文档自译</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>android.os.Parcelable接口的已知间接子类很多，这里就不列举了：</p>
<pre><code><span class="keyword">Class</span> Overview

<span class="keyword">Interface</span> <span class="keyword">for</span> classes whose instances can be written <span class="keyword">to</span> <span class="keyword">and</span> restored <span class="keyword">from</span> a 
Parcel. Classes implementing the Parcelable <span class="keyword">interface</span> must also have a <span class="keyword">static</span> 
field called CREATOR, which <span class="keyword">is</span> an <span class="built_in">object</span> implementing the Parcelable.Creator 
<span class="keyword">interface</span>.
</code></pre><p>该Interface用于实例可以被写入，并且可以从Parcel中恢复的classes(对于Parcel暂时只要知道它是一个存<br>放数据的容器就好了，我会在android IPC中写到它)。实现android.os.Parcelable接口的类必须持有一个实<br>现了android.os.Parcelable接口的名为 CREATOR 的静态字段。</p>
<p>android.os.Parcelable接口典型使用方式,这是官网的例子：</p>
<pre><code>package me.androiddemo.canglangwenyue.androiddemo;

import android.os.Parcel;
import android.os.Parcelable;

<span class="comment">/**
 * Created by canglangwenyue on 12/5/14.
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="title">implements</span> <span class="title">Parcelable</span> {
<span class="keyword">private</span> <span class="keyword">int</span> mData;

<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel <span class="keyword">out</span>, <span class="keyword">int</span> flags)</span> </span>{
    <span class="keyword">out</span>.writeInt(mData);
}

<span class="keyword">public</span> <span class="keyword">static</span> final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
        = <span class="keyword">new</span> Parcelable.Creator&lt;MyParcelable&gt;() {
    <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel <span class="keyword">in</span>)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(<span class="keyword">in</span>);
    }

    <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) {
        <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];
    }
};

<span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel <span class="keyword">in</span>)</span> </span>{
    mData = <span class="keyword">in</span>.readInt();
}
}
</code></pre><p>Summary(简介)</p>
<p>Nested Classes(嵌套类)    </p>
<pre><code><span class="number">1.</span><span class="keyword">interface</span>    Parcelable.ClassLoaderCreator&lt;T&gt;
    Specialization <span class="keyword">of</span> Parcelable.Creator that allows you <span class="keyword">to</span> receive
    the ClassLoader the <span class="built_in">object</span> <span class="keyword">is</span> being created <span class="keyword">in</span>.

解析：专业化的 Parcelable.Creator，允许你接收的<span class="built_in">Object</span>内部创建的 ClassLoader 对象. 

<span class="number">2.</span><span class="keyword">interface</span>    Parcelable.Creator&lt;T&gt;     
<span class="keyword">Interface</span> that must be implemented <span class="keyword">and</span> provided <span class="keyword">as</span> a <span class="keyword">public</span> CREATOR field that
 generates instances <span class="keyword">of</span> your Parcelable <span class="keyword">class</span> <span class="keyword">from</span> a Parcel. 
 解析：该接口必须被子类实现，而且CREATOR 作为公有字段来提供，CREATOR 用于从 Parcel中实例化你的可包装类.
</code></pre><p>Constants(常量)</p>
<pre><code>1.int    CONTENTS_FILE_DESCRIPTOR     
Bit masks for <span class="operator"><span class="keyword">use</span> <span class="keyword">with</span> describeContents(): <span class="keyword">each</span> <span class="built_in">bit</span> represents a kind <span class="keyword">of</span> object
 considered <span class="keyword">to</span> have potential special significance <span class="keyword">when</span> marshalled.

解析：用于 describeContents() 的位掩码，每一位代表它编组时附加的特殊含义。

<span class="number">2.</span><span class="built_in">int</span>    PARCELABLE_WRITE_RETURN_VALUE     
Flag <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">with</span> writeToParcel(Parcel, <span class="built_in">int</span>): the object being written <span class="keyword">is</span> a 
<span class="keyword">return</span> <span class="keyword">value</span>, that <span class="keyword">is</span> the result <span class="keyword">of</span> a <span class="keyword">function</span> such <span class="keyword">as</span> <span class="string">"Parcelable 
someFunction()"</span>, <span class="string">"void someFunction(out Parcelable)"</span>, <span class="keyword">or</span> <span class="string">"void 
someFunction(inout Parcelable)"</span>.

解析：writeToParcel(Parcel, <span class="built_in">int</span>)的标志位：作为一个返回值，是<span class="string">"Parcelable 
someFunction()"</span>, <span class="string">"void someFunction(out Parcelable)"</span>, <span class="keyword">or</span> <span class="string">"void 
someFunction(inout Parcelable)"</span>返回的result。</span>
</code></pre><p>Public Methods(公共method)</p>
<pre><code><span class="number">1.</span><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span>     <span class="title">describeContents</span><span class="params">()</span>
Describe the kinds of special objects contained <span class="keyword">in</span> <span class="keyword">this</span> Parcelable's marshalled
 representation.

 解析：描述各种特殊对象，它们包含在可包装对象的编组形式中.

2.<span class="keyword">abstract</span> <span class="keyword">void</span>     <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span>
Flatten <span class="keyword">this</span> <span class="keyword">object</span> <span class="keyword">in</span> to a Parcel.

解析：将该对象展开到<span class="title">Parcel</span><span class="params">(存放数据的容器)</span>中。</span>
</code></pre><p>Parcelable适用于通过Intent来传递自定义对象。最后给出一个用Parcelable进行数据传送的例子</p>
<p>1.发送Object的Activity，内容很简单，点击Button，Intent携带Object跳转到MainActivity2(用来接收Object的Activity)。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.Button;

<span class="keyword">import</span> java.util.HashMap;

<span class="javadoc">/**
 *<span class="javadoctag"> @author</span> canglangwenyue
 * 用来发送信息的Activity
 */</span>

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

<span class="keyword">private</span> Button sendButton;

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    sendButton = (Button) findViewById(R.id.send_button);

    sendButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
            Intent intent = <span class="keyword">new</span> Intent();
            Person person = <span class="keyword">new</span> Person();

            person.name = <span class="string">"WenYue"</span>;
            intent.putExtra(<span class="string">"WenYue"</span>,person);
            intent.setClass(MainActivity.<span class="keyword">this</span>,MainActivity2.class);

            startActivity(intent);
        }
    });

}


<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>{
    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
    getMenuInflater().inflate(R.menu.menu_main, menu);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>{
    <span class="comment">// Handle action bar item clicks here. The action bar will</span>
    <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
    <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
    <span class="keyword">int</span> id = item.getItemId();

    <span class="comment">//noinspection SimplifiableIfStatement</span>
    <span class="keyword">if</span> (id == R.id.action_settings) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onOptionsItemSelected</span><span class="params">(item)</span></span>;
}
}
</code></pre><p>2.MainActivity2用来接收来自MainActivity的Object，并打印Person.name的长度和content。</p>
<pre><code>package me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.util.Log;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;

<span class="comment">/**</span>
</code></pre><ul>
<li>@author canglangwenyue</li>
<li><p>接收数据的Intent<br>  */</p>
<p> public class MainActivity2 extends ActionBarActivity {</p>
<p> @Override<br> protected void onCreate(Bundle savedInstanceState) {</p>
<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main_activity2);

Intent intent = getIntent();

Person person = intent.getParcelableExtra(<span class="string">"WenYue"</span>);

<span class="keyword">Log</span>.<span class="literal">e</span>(<span class="string">"MainActivity2 received message's length-----&gt;"</span>,String.valueOf(person.name.<span class="literal">length</span>()));
<span class="keyword">Log</span>.<span class="literal">e</span>(<span class="string">"MainActivity2 received message content------&gt;"</span>,person.name);
</code></pre><p> }</p>
</li>
</ul>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>{
    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
    getMenuInflater().inflate(R.menu.menu_main_activity2, menu);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>{
    <span class="comment">// Handle action bar item clicks here. The action bar will</span>
    <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
    <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
    <span class="keyword">int</span> id = item.getItemId();

    <span class="comment">//noinspection SimplifiableIfStatement</span>
    <span class="keyword">if</span> (id == R.id.action_settings) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onOptionsItemSelected</span><span class="params">(item)</span></span>;
}
}
</code></pre><p>3.Parcelable的实现，具体细节前面已经讲到了，就不多说了。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.os.Parcel;
<span class="keyword">import</span> android.os.Parcelable;

<span class="javadoc">/**
 * Created by canglangwenyue on 12/5/14.
 * Parcelable常用于Intent中进行自定义对象的传递
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{


<span class="keyword">public</span> String name;

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>{

    dest.writeString(name);

}

<span class="comment">/*
需要重写Creator实现android.os.Parcelable接口的类必须持有一个实现了android.os.Parcelable接口的名为 CREATOR 的静态字段
 */</span>

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;() {

    <span class="comment">/*
    重写Creator方法
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>{
        Person person = <span class="keyword">new</span> Person();
        person.name = source.readString();
        <span class="keyword">return</span> person;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) {
        <span class="keyword">return</span> <span class="keyword">new</span> Person[<span class="number">0</span>];
    }

};

}
</code></pre><p>最后给出在MainActivity2中log打印的结果，眼见为实，哈哈：</p>
<p><img src="http://cl.ly/image/0n1T2a3Y443M/Parcelable.png" alt="Alt text"></p>
<p>再附上demo下载地址，希望对大家与帮助：<br><a href="http://download.csdn.net/detail/u010835702/8227511" target="_blank" rel="external">苍狼问月</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/05/androidosparcelable文档自译/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/05/androidosparcelable文档自译/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/05/androidosparcelable文档自译/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js" type="text/javascript"></script>
<script src="/js/cover.js" type="text/javascript"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2015 Wenyue
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"wenyue"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>