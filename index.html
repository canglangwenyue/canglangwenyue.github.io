<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Wenyue‘s Blog</title>
  <meta name="author" content="Wenyue">
  
  <meta name="description" content="java web android">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Wenyue‘s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Wenyue‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css" type="text/css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" type="text/css">
<link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-368771XX-X']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>

<body>
  <header id="header" class='normal_mode'>
    <nav id="main-nav">
  <ul class='container'>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
  </header>
  <div id="content" class="container">
    <div id="cover">
	<div id="profile" alt="http://ww1.sinaimg.cn/large/6cea169fjw1edgyzma1xcj21kw16ohba.jpg">
		<a href="/">
			<div class="logo">
				<img src="/logo.png" alt="Profile Picture">
			</div>
			<div id="title">Wenyue‘s Blog</div>
		</a>

		
			<div id="subtitle">他年我若为青帝，抱死桃花一处开!</div>
		
		 <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/canglangwenyue" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="http://weibo.com/u/5578954920" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
 <li>
   	<a href="mailto:canglangwenyue@icloud.com" class="email" target="_blank" title="Email Me">
  		<i class="fa fa-envelope"></i>
  	</a>
 </li>
 
</ul>
	</div>
</div>


  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-03-30T12:35:38.000Z"><a href="/2015/03/30/我的2014_2015/">周一, 3月 30 2015, 8:35:38 晚上</a></time>

  
    <h1 class="title"><a href="/2015/03/30/我的2014_2015/">我的2014_2015</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/点滴/">点滴</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <pre><code>话说，2014年已经逝去很久很久了，马上就是2015年四月了。今天中午回到学校，恰逢后天是四月一日。因为
曾今自己的一个目标的起点便是四月一日。所以，决定在今天写点东西，权当是记录自己的成长轨迹，也希望对
如我一般的后来者有所帮助。记得曾今我写过一篇文章，记录自己的心情，而今这片算是在当时的基础上进一步
确定了自己的目标吧。
</code></pre><p><a href="http://canglangwenyue.com/2014/12/03/%E5%86%99%E7%BB%99%E6%88%91%E4%B8%A4%E5%B9%B4%E9%9B%B6%E4%B8%89%E4%B8%AA%E6%9C%88%E7%9A%84%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/" target="_blank" rel="external">写给我的两年零三个月的大学生活</a></p>
<pre><code>曾今的我很犹豫，也很迷茫，现在依旧是在不断的摸索。曾今我计划拿到里巴巴的实习offer；而今，我提前
完成了自己的目标，于2015年三月十九日拿到了阿里巴巴的实习offer，并同意了意向书。之后又拿到了另外
一些公司的offer，其中有几个很不错的创业团队，大多是B轮这样的。当然，时至今日，我下定决心先去阿里
发展了，这里面涉及到很多的原因与纠结。
</code></pre><h6 id="#当然，说了很多，只为记录自己走过的路，和对未来的展望。经了挺多事，接触了不少大牛，其实我现在才意识到：">#当然，说了很多，只为记录自己走过的路，和对未来的展望。经了挺多事，接触了不少大牛，其实我现在才意识到：</h6><h2 id="所谓大牛不过是在某一领域持续的投入和对时机的把握吧。只要你有很高的执行效率，并坚持付出，不需多久，你自可在某一专注领域崭露头角"><strong>所谓大牛不过是在某一领域持续的投入和对时机的把握吧。只要你有很高的执行效率，并坚持付出，不需多久，你自可在某一专注领域崭露头角</strong></h2><p>所以，这个世界你付出了，并且能够抓住机会，那么你总可以做些什么。</p>
<p>最后，基于最近的一些列面试，我想制定自己的接下来的学习计划：</p>
<pre><code><span class="number">1.</span>重新学习<span class="keyword">C</span>和<span class="keyword">C</span>++，虽然曾今投入了很多，但是随着学习的深入，我才意识到这一块的重要性；

<span class="number">2.</span>回头学习计算机组成结构相关课程，为后来的学习做铺垫；

<span class="number">3.</span>学习Linux相关知识，是真正的深入学习，而非之前的了解；

<span class="number">4.</span>阅读android源码，并学习源码，而非简单地理解所谓的机制，要结合Linux层考虑它的实现，多问What，
How，Why；

<span class="number">5.</span>回头复习中等程度的算法，并尝试在android开发中运用更多的设计模式，曾今在做java web时用的较多
，现在发觉这一块值得花更多时间来投入；

<span class="number">6.</span>将敏捷开发技能真正用于开发，而非停留在书本，如TDD之类；
</code></pre><p>以上，可以算是我之后的成长之路吧，权当记录自己的脚步，亦希望能够对以后和我面对同样境地的人有所帮助。仍然用我最喜欢的那句话结束这篇牢骚文吧:”他年我若为青帝，抱死桃花一处开”。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/03/30/我的2014_2015/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2015/03/30/我的2014_2015/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/03/30/我的2014_2015/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2015-03-04T02:04:58.000Z"><a href="/2015/03/04/android-intent-机制/">周三, 3月 4 2015, 10:04:58 上午</a></time>

  
    <h1 class="title"><a href="/2015/03/04/android-intent-机制/">android Intent 机制</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>一. Intent 对象</p>
<p>1.1什么是Intent</p>
<p>首先呢，大家要明确一点android时基于组件的应用开发。所以，开发过程中我们不仅要寻找和构造符合需求的组件，更重要的是，要将组件有机的连接起来，互相交换信息，这样才能构建出我们最终想要的应用程序。所以，intent便是用来组件之间连接并通信的模式。</p>
<p>1.2.Intent 的构成</p>
<pre><code>(<span class="number">1</span>) <span class="keyword">Action</span>项(谓语)
在<span class="type">Intent</span>对象中用<span class="keyword">Action</span>来表达动作，当调用组件指定一个<span class="keyword">Action</span>后，执行组件就会按照这个<span class="keyword">Action</span>的指示执行相关操作；
(<span class="number">2</span>) <span class="type">Data</span>项(宾语)
当调用组件(主语)发起请求时，如果该组件有明确的数据对象，通常就会用<span class="type">Data</span>项来进行存储。
(<span class="number">3</span>) <span class="keyword">Type</span>项
<span class="type">Data</span>用于描述具体操作目标的需求，例如：“我（调用组件）喝（<span class="keyword">Action</span>动作）王老吉（<span class="type">Data</span>项）”。而<span class="keyword">Type</span>就用于表示“我喝饮料”。即：<span class="type">Data</span>用于特指，而<span class="keyword">Type</span>用于泛指。
(<span class="number">4</span>) Category项
Category用于表述在特定场合下的约束条件。例如：“当我口渴的时候，我喝王老吉”，说明“口渴了”是“喝王老吉”这个<span class="type">Intent</span>的条件。
(<span class="number">5</span>) Component项
Component项指的是目标组件的类型信息。制定了Component后，<span class="type">Intent</span>就变成了单纯的信息载体只负责传递消息和数据。
(<span class="number">6</span>) Extras项
Extras项是<span class="type">Intent</span>数据传输的载体负责将数据从调用组件传递到实现组件。
(<span class="number">7</span>)    Flags 项
Flags是一个整型数，是调用组件指定组件管理服务构造实现组件的方式。
</code></pre><p> 1.3.Intent 的分类</p>
<pre><code>(<span class="number">1</span>) 在意图机制中，组件管理服务负责接受和分析<span class="type">Intent</span>对象，为调用组件选择最合适的实现组件。从实现组件的选择来看，<span class="type">Intent</span>对象可以分成两类：精确描述的 <span class="type">Intent</span>(Explicit <span class="type">Intent</span>－显示<span class="type">Intent</span>)和模糊描述的<span class="type">Intent</span>(<span class="type">Implicit</span> <span class="type">Intent</span> －隐式<span class="type">Intent</span>)。
</code></pre><p>1.4 Intent Filter 对象</p>
<pre><code><span class="type">Intent</span> Filter是各个组件用于描述其功能的，通过组建的<span class="type">Intent</span> Filter信息，android组件管理应用就可以掌握各个组件所具备的能力和可以处理的请求。而且，<span class="type">Intent</span> Filter对象的每个数据项的结构和含义，与<span class="type">Intent</span>中的数据项一一对应。
</code></pre><p>二. Intent匹配</p>
<p>1.Intent 匹配的算法流程</p>
<pre><code><span class="number">1.1</span> <span class="keyword">Action</span> 的比较：
每个<span class="type">Intent</span> Filter 对象都必须包含<span class="keyword">Action</span>信息，如果没有，则对任何一个<span class="type">Intent</span>对象，都会匹配失败。
<span class="number">1.2</span> <span class="type">Data</span> 和 <span class="keyword">Type</span> 的比较
<span class="number">1.3</span> Category 的比较
</code></pre><p>三. Intent 的使用</p>
<p>1.显式调用</p>
<p>显式调用时必须制定组件名称，例如：</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> ＝ new <span class="type">Intent</span>();
<span class="type">intent</span>.setClass(A.this,B.<span class="keyword">class</span>);        //指定了调用组件和实现组件
A.this.startActivity(<span class="type">intent</span>);
</code></pre><p>2.隐式调用</p>
<p>（1）隐式调用并传递Extra附加数据与静态广播的使用</p>
<pre><code>首先实现<span class="type">Intent</span>的调用代码

<span class="type">Intent</span> intent_BroaadCast = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="string">"Intent_1112"</span>);
intent_BroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"LA_LA_LA"</span>);
<span class="type">MainActivity</span>.<span class="keyword">this</span>.sendBroadcast(intent_BroaadCast);

实现静态<span class="type">BroadCastReceiver</span>

<span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.<span class="type">BroadcastReceiver</span>;
<span class="keyword">import</span> android.content.<span class="type">Context</span>;
<span class="keyword">import</span> android.content.<span class="type">Intent</span>;
<span class="keyword">import</span> android.widget.<span class="type">Toast</span>;

<span class="comment">/**
 * Created by canglangwenyue on 15-3-5.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">TestBroadCastReceiver</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BroadcastReceiver</span> {</span>
    <span class="annotation">@Override</span>
    public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) {
        <span class="type">Toast</span>.makeText(context,                         intent.getExtras().getString(<span class="string">"StringTest"</span>),<span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>).show();
    }
}

注册<span class="type">Receiver</span>

&lt;receiver android:name=<span class="string">".TestBroadCastReceiver"</span>&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=<span class="string">"Intent_1112"</span>&gt;&lt;/action&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;

注意：再manifest中注册时action的name应与<span class="type">Intent</span> intent_BroaadCast = <span class="keyword">new</span>         <span class="type">Intent</span>(<span class="string">"Intent_1112"</span>);中的name保持一致。
</code></pre><p> (2) 隐式调用并传递Extra附加数据与动态广播的使用</p>
<pre><code> 首先，新建一个<span class="type">BroadCastReceiver</span>类

 <span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.<span class="type">BroadcastReceiver</span>;
<span class="keyword">import</span> android.content.<span class="type">Context</span>;
<span class="keyword">import</span> android.content.<span class="type">Intent</span>;
<span class="keyword">import</span> android.widget.<span class="type">Toast</span>;

<span class="comment">/**
 * Created by canglangwenyue on 15-3-5.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">MyBroadCast</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">BroadcastReceiver</span> {</span>
    <span class="annotation">@Override</span>
    public void onReceive(<span class="type">Context</span> context, <span class="type">Intent</span> intent) {

                                                    <span class="type">Toast</span>.makeText(context,intent.getExtras().getString(<span class="string">"StringTest"</span>),
                                                    <span class="type">Toast</span>.<span class="type">LENGTH_LONG</span>
).show();

    }
}

其次，再<span class="type">Activity</span>的onCreate中动态添加<span class="type">IntentFilter</span>，并注册<span class="type">BroadCastReceiver</span>；并在
onStop中取消该<span class="type">BroadCastReceiver</span>。

<span class="type">IntentFilter</span> filter = <span class="keyword">new</span> <span class="type">IntentFilter</span>();
<span class="keyword">private</span> <span class="type">MyBroadCast</span> broadCast = <span class="keyword">new</span> <span class="type">MyBroadCast</span>();

<span class="annotation">@Override</span>
<span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(<span class="type">R</span>.layout.activity_main);

    filter.addAction(<span class="string">"MyBroadCast"</span>);
    registerReceiver(broadCast, filter);

}

 <span class="annotation">@Override</span>
<span class="keyword">protected</span> void onStop() {
    unregisterReceiver(broadCast);
    <span class="keyword">super</span>.onStop();
}

使用该类型<span class="type">Intent</span>的代码：

  <span class="type">Intent</span> intent_ActiveBroaadCast = <span class="keyword">new</span> <span class="type">Intent</span>();
intent_ActiveBroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"阿哈"</span>);
intent_ActiveBroaadCast.setAction(<span class="string">"MyBroadCast"</span>);
<span class="type">MainActivity</span>.<span class="keyword">this</span>.sendBroadcast(intent_ActiveBroaadCast);
</code></pre><p> (3) 不使用广播的Intent</p>
<pre><code> 除了广播来触发<span class="type">Intent</span>的<span class="keyword">Action</span>外，我们还可以使用startActivity()方法来实现相同功能。

     <span class="keyword">public</span> void ButtonClick4(View view) {

    /**
     * 注意：
     * 此处因为有动态声明的BroadCastReceiver，所以运行改方法后程序会奔溃，但是此处因为时范        例，便于对比，所以我并没有新建project
     */

    <span class="type">Intent</span> intent_ActiveBroaadCast = new <span class="type">Intent</span>(<span class="string">"myTest111"</span>);
    intent_ActiveBroaadCast.putExtra(<span class="string">"StringTest"</span>, <span class="string">"德玛西亚"</span>);
    MainActivity.this.startActivity(intent_ActiveBroaadCast);
}      

   然后我们必须在该<span class="type">intent</span>想要启动的实现组件中添加IntentFilter来截获，否则就无法匹配到实现组件。

   &lt;activity
        android:<span class="keyword">name</span>=<span class="string">".Activity2"</span>
        android:label=<span class="string">"@string/title_activity_activity2"</span> &gt;
        &lt;<span class="type">intent</span>-filter&gt;
            &lt;<span class="keyword">action</span> android:<span class="keyword">name</span>=<span class="string">"myTest111"</span>&gt;&lt;/<span class="keyword">action</span>&gt;
            &lt;category android:<span class="keyword">name</span>=<span class="string">"android.intent.category.DEFAULT"</span>&gt;&lt;/    category&gt;
        &lt;/<span class="type">intent</span>-filter&gt;
    &lt;/activity&gt; 
需要注意的是：首先，<span class="keyword">action</span> <span class="keyword">name</span>应该保持一致；其次，必须声明
&lt;categoryandroid:<span class="keyword">name</span>=<span class="string">"android.intent.category.DEFAULT"</span>&gt;&lt;/category&gt;，因为，我们在
使用<span class="type">intent</span>时并没有指定category，所以，系统默认添加了<span class="keyword">DEFAULT</span>，故如果不在&lt;<span class="type">intent</span>-filter&gt;进
行声明，则无法匹配到Activity。
</code></pre><p> (4) 使用系统自带的一些标准Action，这里只列举一二：</p>
<pre><code> 获取联系人列表

    <span class="built_in">Uri</span> uri = <span class="built_in">Uri</span>.parse(<span class="string">"content://contacts"</span>);
    Intent pickContactIntent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, uri);
      pickContactIntent.setType(ContactsContract.CommonDataKinds.
      Phone.CONTENT_TYPE); <span class="comment">//         Show user only contacts w/ phone numbers</span>
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);  

拨打电话

    <span class="built_in">Uri</span> number = <span class="built_in">Uri</span>.parse(<span class="string">"tel:187008*****"</span>);
    Intent callIntent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL, number);

    startActivity(callIntent);
</code></pre><p>四. Intent 传输数据<br>    android 界面组件间通过要通过Intent来实现，Intent传递数据的方式有两种</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2015/03/04/android-intent-机制/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2015/03/04/android-intent-机制/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2015/03/04/android-intent-机制/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-28T09:20:10.000Z"><a href="/2014/12/28/关于大学生创业之我见/">周日, 12月 28 2014, 5:20:10 下午</a></time>

  
    <h1 class="title"><a href="/2014/12/28/关于大学生创业之我见/">关于大学生创业之我见</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/点滴/">点滴</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>时间，对于有限生命的个体而言，永远是个无法结束的话题。从上大学到现在，环境变了，接触到的事物变了，认识的人也不一样了，交际圈更是发生了巨大的变化，心境也是发生了很大变化。自古英雄出少年，昨日凌云壮志仍在我心，初心未改，然，路在何方？</p>
<p>一直以来，在我心中，萦绕着一个问题，我以后一定要自己创业，成就一片属于自己的天空。最近偶有所感，权当记录，以后自有我的人生来印证！</p>
<pre><code>IT相关行业大学上究竟如何才能做好创业的准备，创业之路又在何方？
</code></pre><p>当你的能力慢慢提升了，你的事业自然就变宽阔了，思考的也就不一样了。现在我觉得IT相关行业的大学生其实相比其他行业，或许更具创业优势。当然这里就仁者见仁，智者见智了。因为，他们自身有技术支持，而且创业成本很低，初期有两三个人即可。所以，很多IT公司都可以从车库起家，但是这种情况放在其他行业便不太可能了。</p>
<p>所以，IT行业学生的又是是显而易见的，但是，他们也有自己的不足，那便是交际圈或者说社交能力，经常是这个原因限制了程序员的发展，更是扼杀了创业的可能性。</p>
<p>就目前的我看来，程序员创业做好三点，便足以活得出奇的成功。</p>
<pre><code>1.强悍而又全面面的技术；

2.高质量的社交圈；

3.对于机会的把握能力和勇于冒险的精神。
</code></pre><p>就这三点，我粗浅的说一下自己的认知吧。</p>
<p>首先，对于第一点，有句古话“苦心人,天不负，卧薪尝胆，三千越甲可吞吴；有志者，事竟成，破釜沉舟，百二秦关终属楚。”坚持，专注，真正的专注，那么你必然会在某一领域独领风骚的。而至于全面，有时候就需要借助来自第二点的力量了。</p>
<p>其次，对于第二点，看看马云周围的人那一个不是富豪？？所以，好的环境会对人有积极的影响，除此之外，有时候你会因此而得贵人相助，甚至指点一下，也将是莫大的收获。</p>
<p>最后，对于第三点。就要靠自己对机会的发觉，以及把握能力了，还有敢不敢拿着自己的身家性命赌一把的豪气。</p>
<p>至此，稀里糊涂，写了这些。我想以后我看到回想起以前的懵懂时光的，哈哈。</p>
<p>是七尺男儿，生能舍己，做千秋雄鬼，死不还家。<br>我为青帝日，桃花一处开。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/28/关于大学生创业之我见/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/28/关于大学生创业之我见/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/28/关于大学生创业之我见/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-08T12:40:48.000Z"><a href="/2014/12/08/android-notification完全解析/">周一, 12月 8 2014, 8:40:48 晚上</a></time>

  
    <h1 class="title"><a href="/2014/12/08/android-notification完全解析/">android notification完全解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>Notifications in Android 4.4 and Lower</p>
<p>notification是很重要的部分，它与service，BroadcastReceiver，Intent等密切相关，很好地使用notification可以使你的app的活跃度相对于没有notification 的app大增。</p>
<p>很明显这篇文章将详细的介绍4.4及以下的notification。至于，android 5.0的相关特性，我计划在假期里开一个特辑来写。下载就当是回顾知识了。毕竟，温故而知新嘛，哈哈。</p>
<pre><code>The notification <span class="keyword">system</span> allows your app <span class="built_in">to</span> keep <span class="operator">the</span> user informed about events,
 such <span class="keyword">as</span> <span class="built_in">new</span> chat messages <span class="operator">or</span> <span class="operator">a</span> calendar event. Think <span class="operator">of</span> notifications <span class="keyword">as</span> <span class="operator">a</span> 
 news channel that alerts <span class="operator">the</span> user <span class="built_in">to</span> important events <span class="keyword">as</span> they happen <span class="operator">or</span> <span class="operator">a</span> <span class="built_in">log</span> 
 that chronicles events <span class="keyword">while</span> <span class="operator">the</span> user is <span class="operator">not</span> paying attention.
</code></pre><p>notification使得你的app可以告知用户app中的事件，例如一条新的message或者一个日历事件。可以认为notification是一个新闻渠道，它用来在用户不注意到的时候来通知用户一些重要事件。</p>
<p>Anatomy of a notification</p>
<pre><code>Base Layout

At <span class="operator">a</span> minimum, all notifications consist <span class="operator">of</span> <span class="operator">a</span> base layout, including:

<span class="operator">the</span> sending application<span class="string">'s notification icon or the sender'</span>s photo
<span class="operator">a</span> notification title <span class="operator">and</span> message
<span class="operator">a</span> timestamp
<span class="operator">a</span> secondary icon <span class="built_in">to</span> identify <span class="operator">the</span> sending application when <span class="operator">the</span> sender<span class="string">'s image is     shown for the main icon</span>
</code></pre><p>notification的基本布局</p>
<p>最低限度，所有的notifications 都由基本布局构成，包括：</p>
<p>发送notification的application的icon或者发送者的image。<br>notification的title和message。<br>时间戳<br>当main icon用来显示sender’s image时 Secondary icon用来显示发送application的icon。</p>
<pre><code>Expanded layouts

You have the option to provide more event detail. You can <span class="operator"><span class="keyword">use</span> this <span class="keyword">to</span> <span class="keyword">show</span> the 
<span class="keyword">first</span> few <span class="keyword">lines</span> <span class="keyword">of</span> a message <span class="keyword">or</span> <span class="keyword">show</span> a larger image preview. This provides the 
<span class="keyword">user</span> <span class="keyword">with</span> additional context, <span class="keyword">and</span> - <span class="keyword">in</span> <span class="keyword">some</span> cases - may allow the <span class="keyword">user</span> <span class="keyword">to</span> <span class="keyword">read</span> 
a message <span class="keyword">in</span> its entirety. The <span class="keyword">user</span> can pinch-zoom <span class="keyword">or</span> two-finger glide <span class="keyword">in</span> <span class="keyword">order</span> 
<span class="keyword">to</span> toggle <span class="keyword">between</span> base <span class="keyword">and</span> expanded layouts. <span class="keyword">For</span> single <span class="keyword">event</span> notifications, 
Android provides two expanded layout templates (<span class="built_in">text</span> <span class="keyword">and</span> image) <span class="keyword">for</span> you <span class="keyword">to</span> re-
<span class="keyword">use</span> <span class="keyword">in</span> your application.</span>
</code></pre><p>notification的扩展布局</p>
<p>你可以选择提供事件的更多细节。你可以用它来显示一个message的一些行或者显示一个图片的预览。这些给用户提供了额外的内容，并且，在一些情况下，可以允许用户阅读完整的信息。用户可以通过 pinch-zoom 或者双手指滑动来打开扩展布局。android为单个notification提供了两种扩展布局的方式(image,text)以供你在你的application中使用。</p>
<p><img src="http://cl.ly/image/44191C3N2g3L/notifications_pattern_anatomy.png" alt="Alt text"></p>
<p><img src="http://cl.ly/image/182S1j201G3T/20140224232357359.jpeg" alt="Alt text"></p>
<p><img src="http://cl.ly/image/0R2Q2L1j060v/notifications_pattern_expandable.png" alt="Alt text"></p>
<p>1.notification的title<br>2.发送notification的application的icon或者发送者的image。<br>3.notification的message<br>4.notification的数目显示<br>5.当main icon用来显示sender’s image时 Secondary icon用来显示发送application的icon。<br>6.时间戳，默认为系统发出通知的时间。</p>
<p>Actions</p>
<pre><code>Android supports optional actions <span class="keyword">that</span> are displayed <span class="keyword">at</span> <span class="keyword">the</span> bottom <span class="keyword">of</span> <span class="keyword">the</span> 
notification. With actions, users can handle <span class="keyword">the</span> most common tasks <span class="keyword">for</span> a 
particular notification <span class="keyword">from</span> within <span class="keyword">the</span> notification shade <span class="keyword">without</span> having <span class="keyword">to</span> 
open <span class="keyword">the</span> originating <span class="type">application</span>. This speeds up interaction <span class="keyword">and</span>, <span class="keyword">in</span> 
conjunction <span class="keyword">with</span> <span class="string">"swipe-to-dismiss"</span>, helps users <span class="keyword">to</span> streamline their 
notification triaging experience.

Be judicious <span class="keyword">with</span> how many actions you include <span class="keyword">with</span> a notification. The more 
actions you include, <span class="keyword">the</span> more cognitive complexity you create. Limit yourself 
<span class="keyword">to</span> <span class="keyword">the</span> fewest <span class="type">number</span> <span class="keyword">of</span> actions possible <span class="keyword">by</span> only including <span class="keyword">the</span> most imminently 
important <span class="keyword">and</span> meaningful ones.

Good candidates <span class="keyword">for</span> actions <span class="function_start"><span class="keyword">on</span></span> notifications are actions <span class="keyword">that</span> are:

essential, frequent <span class="keyword">and</span> typical <span class="keyword">for</span> <span class="keyword">the</span> content type you're displaying
<span class="property">time</span>-critical
<span class="keyword">not</span> overlapping <span class="keyword">with</span> neighboring actions
Avoid actions <span class="keyword">that</span> are:

ambiguous，duplicative <span class="keyword">of</span> <span class="keyword">the</span> default action <span class="keyword">of</span> <span class="keyword">the</span> notification (such <span class="keyword">as</span> <span class="string">"Read"</span> <span class="keyword">or</span> <span class="string">"Open"</span>)
</code></pre><p>android支持在notification的地步显示可选的操作。有了这些actions，用户可以处理大多数相同的tasks而无需打开应用。这集快乐交互的速度，并且结合滑动消失使得用户简化其通知处理的经历。</p>
<p>明智的决定在你的notification里面放置的action的数量。如果你包含了更多的action，那么你便增加了交互的复杂性。请选择一个或者两个很重要并且有意义的action。</p>
<p>好的候选action有以下的特点：</p>
<p>.对该通知时重要的，典型的，并且频繁使用的action。<br>.时间紧迫的<br>.不要和相邻的action产生重叠</p>
<p>避免以下操作：</p>
<p>.含糊不清地<br>.和点击notification的action重复的(such as “Read” or “Open”)</p>
<p>Design guidelines</p>
<p>.个性化<br>.导航到正确的地方<br>.正确的设置通知的优先级</p>
<p>主要看一下优先级的设置吧，其他的解释大家可以参考官网。<br>用方法setPriority(int pri)来指定优先级</p>
<p><img src="http://cl.ly/image/2Y2f122Y2r0E/notifications_pattern_priority.png" alt="Alt text"></p>
<p>对应的属性如下：</p>
<p>Notification.PRIORITY_DEFAULT(优先级为0)<br>Notification.PRIORITY_HIGH<br>Notification.PRIORITY_LOW<br>Notification.PRIORITY_MAX(优先级为2)<br>Notification.PRIORITY_MIN(优先级为-2)</p>
<p>现在，我们来看一下，如何实现一个notification。估计大家现在最常用的做法是下面这种：</p>
<pre><code>Notification notification = <span class="keyword">new</span> Notification(R.drawable.ic_launcher, 
getText(R.<span class="built_in">string</span>.app_name),
           System.currentTimeMillis());

   Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.<span class="keyword">class</span>);
   PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, 
   notificationIntent, <span class="number">0</span>);
   notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.<span class="built_in">string</span>.hello_world),
           getText(R.<span class="built_in">string</span>.hello_world), pendingIntent);
   startForeground(<span class="number">1</span>, notification);
</code></pre><p>这是在service里面启动一个notification，但是大家一定记住这种方法已经过时了，也就是说Google官方已经不提倡使用这种方法来启动一个notification了。官方推荐使用V4包下NotificationCompat.Builder，这样，我们便可以设置各种属性。</p>
<p>好了，现在我们具体来看一下，Notification的具体实现。</p>
<p>1.创建一个简单的notification。</p>
<p><img src="http://cl.ly/image/182S1j201G3T/20140224232357359.jpeg" alt="Alt text"></p>
<pre><code>Required notification contents
notification必须要包含的内容

A Notification <span class="tag">object</span> must contain the following:
一个notification必须包含下面的属性：

A small <span class="attribute">icon</span>, set by <span class="function"><span class="title">setSmallIcon</span><span class="params">()</span></span>
一个small <span class="attribute">icon</span>，用<span class="function"><span class="title">setSmallIcon</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">2</span>号区域

A title, set by <span class="function"><span class="title">setContentTitle</span><span class="params">()</span></span>
一个title，用<span class="function"><span class="title">setContentTitle</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">1</span>号区域

Detail text, set by <span class="function"><span class="title">setContentText</span><span class="params">()</span></span>
详细文本，用<span class="function"><span class="title">setContentText</span><span class="params">()</span></span>来设置，对应于上图中的<span class="number">3</span>号区域
</code></pre><p>这三个是必须设置的，至于其他的扩展则是需求而定。代码如下：</p>
<pre><code> <span class="keyword">private</span> NotificationManager manager;

NotificationCompat.Builder notifyBuilder;

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    <span class="comment">/*实例化NotificationManager以获取系统服务*/</span>
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

}

<span class="javadoc">/**
 * 显示最简单的通知，以下method中的三个set方法是必须设置的
 *
 *<span class="javadoctag"> @param</span> view
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">simNotification</span><span class="params">(View view)</span> </span>{

    Toast.makeText(<span class="keyword">this</span>, <span class="string">"hha"</span>, Toast.LENGTH_LONG).show();

    notifyBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)
            <span class="comment">/*设置small icon*/</span>
            .setSmallIcon(R.drawable.ic_launcher)
            <span class="comment">/*设置title*/</span>
            .setContentTitle(<span class="string">"通知"</span>)
            <span class="comment">/*设置详细文本*/</span>
            .setContentText(<span class="string">"Hello world"</span>);
    manager.notify(<span class="number">100</span>, notifyBuilder.build());
}
</code></pre><p>代码里的注释已经很详细了，simNotification绑定到了一个Button。这样，我们已经实现了最简单的notification。</p>
<p>2.创建一个点击跳转到其它Activity的Notification。</p>
<pre><code> /<span class="keyword">*</span><span class="keyword">*</span>
 <span class="keyword">*</span> 点击跳转到指定Activity
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param view</span>
 <span class="keyword">*</span>/
public void largePicture(View view) {
     /<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    //点击的意图ACTION是跳转到Intent
    Intent resultIntent = new Intent(this, MainActivity.class);
    resultIntent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
    notifyBuilder = new NotificationCompat.Builder(this)
            /<span class="keyword">*</span>设置large icon<span class="keyword">*</span>/
            .setLargeIcon(bitmap)
             /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
            .setSmallIcon(R.drawable.ic_launcher)
            /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
            .setContentTitle(<span class="string">"通知"</span>)
            /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
            .setContentText(<span class="string">"Hello world"</span>)
             /<span class="keyword">*</span>设置发出通知的时间为发出通知时的系统时间<span class="keyword">*</span>/
            .setWhen(System.currentTimeMillis())
             /<span class="keyword">*</span>设置发出通知时在status bar进行提醒<span class="keyword">*</span>/
            .setTicker(<span class="string">"来自问月的祝福"</span>)
            /<span class="keyword">*</span>setOngoing(boolean)设为true,notification将无法通过左右滑动的方式清除
            <span class="keyword">*</span> 可用于添加常驻通知，必须调用cancle方法来清除
            <span class="keyword">*</span>/
            .setOngoing(true)
             /<span class="keyword">*</span>设置点击后通知消失<span class="keyword">*</span>/
            .setAutoCancel(true)
             /<span class="keyword">*</span>设置通知数量的显示类似于QQ那种，用于同志的合并<span class="keyword">*</span>/
            .setNumber(2)
             /<span class="keyword">*</span>点击跳转到MainActivity<span class="keyword">*</span>/
            .setContentIntent(pendingIntent);

    manager.notify(121, notifyBuilder.build());
}
</code></pre><p>代码里的注释都很详细，加上前面的介绍相信大家都能理解了。</p>
<p>3.创建一个显示bitmap的notification，类似于屏幕截图的显示效果</p>
<p><img src="http://cl.ly/image/1Q1s2Q012m1O/big_picture_notification.png" alt="Alt text"></p>
<p> /**</p>
<pre><code> <span class="keyword">*</span> 类似于系统截图的效果
 <span class="keyword">*</span>
 <span class="keyword">*</span> <span class="comment">@param view</span>
 <span class="keyword">*</span>/
public void comNotification(View view) {

    /<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    /<span class="keyword">*</span>获取bitmap<span class="keyword">*</span>/
    Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher);
    notifyBuilder = new NotificationCompat.Builder(this)
             /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
            .setSmallIcon(R.drawable.ic_launcher)
            /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
            .setContentTitle(<span class="string">"通知"</span>)
            /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
            .setContentText(<span class="string">"Hello world"</span>)
            .setWhen(System.currentTimeMillis())
            .setOngoing(true)
            .setNumber(2);

    NotificationCompat.BigPictureStyle bigPictureStyle = new NotificationCompat.BigPictureStyle();
    bigPictureStyle.bigPicture(bitmap);
    notifyBuilder.setStyle(bigPictureStyle);

    manager.notify(121, notifyBuilder.build());
}
</code></pre><p>这里唯一需要注意的是加载图片最好不要在UI线程进行(这里只是为了演示)。</p>
<p>4.创建一个类似于日历事件的notification，并与Service进行交互。</p>
<p><img src="http://cl.ly/image/2c3p2b3C2o0x/add_notification.png" alt="Alt text"></p>
<pre><code> <span class="comment">/**
 * 创建一个类似于日历事件的notification
 * @param view
 */</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_action</span><span class="params">(View view)</span> </span>{

    myIntent = <span class="keyword">new</span> Intent(getApplicationContext(), MyIntentService.<span class="keyword">class</span>);

    myIntent.putExtra(myConstants.EXTRA_MESSAGE, <span class="string">" 来自问月的祝福"</span>);
    myIntent.setAction(myConstants.ACTION_PING);
    myIntent.putExtra(myConstants.EXTRA_TIMER, <span class="number">1000</span>);
    startService(myIntent);

}
</code></pre><p>IntentService代码如下，之后在需要时可以在此扩展IntentService，这里注意一下IntentService类的构造器的重载，super里面是你的路径名。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.test;

<span class="keyword">import</span> android.app.IntentService;
<span class="keyword">import</span> android.app.Notification;
<span class="keyword">import</span> android.app.NotificationManager;
<span class="keyword">import</span> android.app.PendingIntent;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v4.app.NotificationCompat;
<span class="keyword">import</span> android.util.Log;

<span class="javadoc">/**
 * Created by canglangwenyue on 14-12-9.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>{

<span class="keyword">private</span> NotificationManager manager;
<span class="keyword">private</span> String message;
<span class="keyword">private</span> <span class="keyword">int</span> mMills;
NotificationCompat.Builder builder;

<span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span> </span>{
    <span class="comment">// The super call is required. The background thread that IntentService</span>
    <span class="comment">// starts is labeled with the string argument you pass.</span>
    <span class="keyword">super</span>(<span class="string">"me.androiddemo.canglangwenyuet.test"</span>);
}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>{

    message = intent.getStringExtra(myConstants.EXTRA_MESSAGE);

    mMills = intent.getIntExtra(myConstants.EXTRA_TIMER, myConstants.DEFAULT_TIMER_DURATION);

    NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    String action = intent.getAction();
    issueNotification(intent,message);

    <span class="keyword">if</span> (action.equals(myConstants.ACTION_PING)) {
        issueNotification(intent,message);
    }<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(action.equals(myConstants.ACTION_SNOOZE)</span>) </span>{
        notificationManager.cancel(myConstants.NOTIFICATION_ID);
        issueNotification(intent,<span class="string">""</span>);
    }<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(action.equals(myConstants.ACTION_DISMISS)</span>) </span>{
        notificationManager.cancel(myConstants.NOTIFICATION_ID);
    }


}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">issueNotification</span><span class="params">(Intent intent, String msg)</span> </span>{
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    Intent dissmissItent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);
    dissmissItent.setAction(myConstants.ACTION_DISMISS);
    PendingIntent disIntent = PendingIntent.getService(<span class="keyword">this</span>,<span class="number">0</span>,dissmissItent,<span class="number">0</span>);

    Intent snoozeIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);
    snoozeIntent.setAction(myConstants.ACTION_SNOOZE);
    PendingIntent snoopIntent = PendingIntent.getService(<span class="keyword">this</span>,<span class="number">0</span>,snoozeIntent,<span class="number">0</span>);

    builder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)
            .setSmallIcon(R.drawable.ic_launcher)
            .setContentTitle(<span class="string">"Information"</span>)
            .setContentText(<span class="string">"lalallalala"</span>)
            .setDefaults(Notification.DEFAULT_ALL)
            .setStyle(<span class="keyword">new</span> NotificationCompat.BigTextStyle().bigText(msg))
            .addAction(R.drawable.ic_launcher, <span class="string">"Dismiss"</span>, disIntent)
            .addAction(R.drawable.ic_launcher,<span class="string">"snooze"</span>,snoopIntent);


    Intent resultIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MainActivity2.class);
    resultIntent.putExtra(myConstants.EXTRA_MESSAGE,msg);
    resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);


    PendingIntent resultPendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,resultIntent,PendingIntent.FLAG_UPDATE_CURRENT);

    builder.setContentIntent(resultPendingIntent);
    <span class="comment">//        manager.notify(myConstants.NOTIFICATION_ID,builder.build());</span>
    startTimer(mMills);



}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startTimer</span><span class="params">(<span class="keyword">int</span> mMills)</span> </span>{
    <span class="keyword">try</span> {

        Thread.sleep(mMills);

    }<span class="keyword">catch</span> (Exception e) {
        Log.d(myConstants.DEBUG_TAG, <span class="string">"ERROR"</span>);
    }
    issueNotification(builder);
}

<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">issueNotification</span><span class="params">(NotificationCompat.Builder builder)</span> </span>{
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

    manager.notify(myConstants.NOTIFICATION_ID,builder.build());
}
}
</code></pre><p>这里只是实现了一个简单的Timer。参考一下就好。</p>
<p>5.创建一个自定义的notification，只要通过RemoteViews来获取你的XML布局文件，并通过.setContent(remoteViews)就好，大家只需要对比不同之处。</p>
<p><img src="http://cl.ly/image/1x2d1m2a0C2t/ustom_notification.png" alt="Alt text"></p>
<pre><code> /**
 * 自定义notification样式
 *
 * @param view
 */
<span class="component">public void Cus_Notification(View view) {

    Toast<span class="string">.makeText(MainActivity.this</span>, "AHa", Toast<span class="string">.LENGTH_LONG).show()</span>;
    /*实例化NotificationManager以获取系统服务*/
    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    RemoteViews remoteViews = new RemoteViews(getPackageName(), R<span class="string">.layout.customnotification)</span>;

    remoteViews<span class="string">.setImageViewResource(R.id.imageView</span>, R<span class="string">.drawable.psb)</span>;
    remoteViews<span class="string">.setTextViewText(R.id.textView</span>, "Your Haven");

    remoteViews<span class="string">.setTextViewText(R.id.textView2</span>, "YUI");
    remoteViews<span class="string">.setTextViewText(R.id.textView3</span>, "豆瓣－FNM －我的红心 MHZ");

    remoteViews<span class="string">.setViewVisibility(R.id.my_large_button</span>, View<span class="string">.VISIBLE)</span>;
    notifyBuilder = new NotificationCompat<span class="string">.Builder(this)</span>
            <span class="string">.setContent(remoteViews)</span>
            <span class="string">.setContentIntent(getDefalutIntent(Notification.FLAG_AUTO_CANCEL))</span>
             /*设置small icon*/
            <span class="string">.setSmallIcon(R.drawable.ic_launcher)</span>
            /*设置title*/
            <span class="string">.setContentTitle("通知")</span>
            /*设置详细文本*/
            <span class="string">.setTicker("Your</span> Haven")
            <span class="string">.setContentText("Hello</span> world")
            <span class="string">.setWhen(System.currentTimeMillis())</span>
            <span class="string">.setPriority(Notification.PRIORITY_DEFAULT)//</span> 设置该通知优先级
            <span class="string">.setOngoing(true)</span>;

    Notification noty = notifyBuilder<span class="string">.build()</span>;
    noty<span class="string">.contentView</span> = remoteViews;
    manager<span class="string">.notify(313</span>, noty);

}</span>
</code></pre><p>这里只是添加了一个ImageView和三个TextView，大家可以进一步扩充，例如添加ImageButton，并通过BroadcastReceiver来监听。</p>
<p>6.最后在写一个带进度条指示器的notification吧，到了这里大家应该理解什么叫求同存异了吧，哈哈。至于其它的notification，例如FullScreen下的notification或者LockScreen的notification等，都是换汤不换药，大家只要按需设置相应的属性就好，具体可以查询官方文档。</p>
<p><img src="http://cl.ly/image/0B0D2h0o001j/process_notification.png" alt="Alt text"></p>
<pre><code><span class="javadoc">/**
 * 有进度条的notification
 *<span class="javadoctag"> @param</span> view
 */</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">Pro_Notification</span><span class="params">(View view)</span> </span>{

    manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
    notifyBuilder = <span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>);
    notifyBuilder.setContentTitle(<span class="string">"Picture Download"</span>)
            .setContentText(<span class="string">"Download in progress"</span>)
            .setOngoing(<span class="keyword">true</span>)
            .setSmallIcon(R.drawable.ic_launcher);
<span class="comment">// Start a lengthy operation in a background thread</span>
    <span class="keyword">new</span> Thread(
            <span class="keyword">new</span> Runnable() {
                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                    <span class="keyword">int</span> incr;
                    <span class="comment">// Do the "lengthy" operation 20 times</span>
                    <span class="keyword">for</span> (incr = <span class="number">0</span>; incr &lt;= <span class="number">100</span>; incr += <span class="number">5</span>) {
                        <span class="comment">// Sets the progress indicator to a max value, the</span>
                        <span class="comment">// current completion percentage, and "determinate"</span>
                        <span class="comment">// state</span>
                        notifyBuilder.setProgress(<span class="number">100</span>, incr, <span class="keyword">false</span>);
                        <span class="comment">// Displays the progress bar for the first time.</span>
                        manager.notify(<span class="number">0</span>, notifyBuilder.build());
                        <span class="comment">// Sleeps the thread, simulating an operation</span>
                        <span class="comment">// that takes time</span>
                        <span class="keyword">try</span> {
                            <span class="comment">// Sleep for 5 seconds</span>
                            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);
                        } <span class="keyword">catch</span> (InterruptedException e) {
                            Log.d(<span class="string">"NOTIFICATION"</span>, <span class="string">"sleep failure"</span>);
                        }
                    }
                    <span class="comment">// When the loop is finished, updates the notification</span>
                    notifyBuilder.setContentText(<span class="string">"Download complete"</span>)
                            <span class="comment">// Removes the progress bar</span>
                            .setProgress(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);
                    manager.notify(<span class="number">213</span>, notifyBuilder.build());
                }
            }
<span class="comment">// Starts the thread by calling the run() method in its Runnable</span>
    ).start();

}
</code></pre><p>大概解释一下，就是在一个异步线程里面每隔5秒使notification的process增加5，循环结束后，在重新添加一个notification来显示下载完成。至于进度还有其他方式设置，这里就不一一介绍了，实际使用时可以传入具体的下载进度。</p>
<p>好了，感觉已经写了好多了，最后来总结一下notification的使用吧。<br>(一)通过以下几个步骤就可以获得一个notification的实现：</p>
<p>1.获取NotificationManager实例，即获得状态通知栏管理权；</p>
<pre><code>/<span class="keyword">*</span>实例化NotificationManager以获取系统服务<span class="keyword">*</span>/
   manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
</code></pre><p>2.实例化notification的constructor</p>
<pre><code>notifyBuilder = new NotificationCompat.<span class="function"><span class="title">Builder</span><span class="params">(this)</span></span>
</code></pre><p>3.对notifyBuilder设置各种属性</p>
<pre><code>/<span class="keyword">*</span><span class="keyword">*</span>
            <span class="keyword">*</span> 前三个属性必须设置
            <span class="keyword">*</span>/
           /<span class="keyword">*</span>设置small icon<span class="keyword">*</span>/
           .setSmallIcon(R.drawable.ic_launcher)
           /<span class="keyword">*</span>设置title<span class="keyword">*</span>/
           .setContentTitle(<span class="string">"通知"</span>)
           /<span class="keyword">*</span>设置详细文本<span class="keyword">*</span>/
           .setContentText(<span class="string">"Hello world"</span>)
            /<span class="keyword">*</span>设置发出通知的时间为发出通知时的系统时间<span class="keyword">*</span>/
           .setWhen(System.currentTimeMillis())
            /<span class="keyword">*</span>设置发出通知时在status bar进行提醒<span class="keyword">*</span>/
           .setTicker(<span class="string">"来自问月的祝福"</span>)
            /<span class="keyword">*</span>设置点击后通知消失<span class="keyword">*</span>/
           .setAutoCancel(true)
                   /<span class="keyword">*</span><span class="keyword">*</span>
                    <span class="keyword">*</span> 设置
                    notification的默认效果有以下几种
                    Notification.DEFAULT_ALL：铃声、闪光、震动均系统默认。
                    Notification.DEFAULT_SOUND：系统默认铃声。
                    Notification.DEFAULT_VIBRATE：系统默认震动。
                    Notification.DEFAULT_LIGHTS：系统默认闪光。
                    <span class="keyword">*</span>/
           .setDefaults(Notification.DEFAULT_VIBRATE)
            /<span class="keyword">*</span>setOngoing(boolean)设为true,notification将无法通过左右滑动的方式清除
           <span class="keyword">*</span> 可用于添加常驻通知，必须调用cancle方法来清除
           <span class="keyword">*</span>/
           .setOngoing(true)
            /<span class="keyword">*</span>设置通知数量的显示类似于QQ那种，用于同志的合并<span class="keyword">*</span>/
           .setNumber(2);
</code></pre><p> 4.显示notification</p>
<pre><code>manager.notify(<span class="number">100</span>, notifyBuilder.build<span class="literal">()</span>);
</code></pre><p> (二)一些常用的属性函数</p>
<p> .setDefaults(int defaults)<br>     用于向通知添加声音、闪灯和振动效果的最简单、使用默认（defaults）属性，具体在上述代码中有写到。</p>
<p> .setVibrate(long[] pattern)<br>     用于设置是否开启震动,true为开启</p>
<p> .setSound(Uri sound)<br>     用于设置通知铃声</p>
<p> .setPriority(int pri)<br>     用于设置优先级，同样之前有详细讲解</p>
<p> .setOngoing(boolean ongoing)<br>     设置为true则为常驻通知栏的通知类似于墨迹天气那种的效果。</p>
<p> setProgress(int max, int progress,boolean indeterminate)<br>     用于设置进度的notification中<br>嗯，今天就写这些吧，最后附上demo的下载地址。<a href="http://download.csdn.net/detail/u010835702/8241469" target="_blank" rel="external">点此下载</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/08/android-notification完全解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/08/android-notification完全解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/08/android-notification完全解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-07T02:31:34.000Z"><a href="/2014/12/07/android-service完全解析/">周日, 12月 7 2014, 10:31:34 上午</a></time>

  
    <h1 class="title"><a href="/2014/12/07/android-service完全解析/">android Service完全解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>老规矩，先看官方文档是怎么说的。</p>
<pre><code>A Service is <span class="operator">an</span> application component that can perform <span class="keyword">long</span>-running operations <span class="operator">in</span>
 <span class="operator">the</span> background <span class="operator">and</span> does <span class="operator">not</span> provide <span class="operator">a</span> user interface. Another application 
 component can <span class="built_in">start</span> <span class="operator">a</span> service <span class="operator">and</span> <span class="keyword">it</span> will continue <span class="built_in">to</span> run <span class="operator">in</span> <span class="operator">the</span> background even 
 <span class="keyword">if</span> <span class="operator">the</span> user switches <span class="built_in">to</span> another application. Additionally, <span class="operator">a</span> component can bind
  <span class="built_in">to</span> <span class="operator">a</span> service <span class="built_in">to</span> interact <span class="operator">with</span> <span class="keyword">it</span> <span class="operator">and</span> even perform interprocess communication 
  (IPC). For example, <span class="operator">a</span> service might handle network transactions, play music, 
  perform <span class="built_in">file</span> I/O, <span class="operator">or</span> interact <span class="operator">with</span> <span class="operator">a</span> content provider, all <span class="built_in">from</span> <span class="operator">the</span> background.
</code></pre><p>以我的理解呢，大概就是说：</p>
<p>service是一个没有用户界面并且运行在后台以执行长时间耗时操作的app application组件。其它的application 组件能够启动service，而且service将一直执行下去，即使用户从当前service所属的application切换到了其它的application。另外，一个组件可以绑定到一个服务来和它交互，甚至是进程间通信(IPC机制)。for example，一个服务可能会处理网络操作，播放音乐，处理文件的IO操作，或者与content provider交互，所有的操作都是在后台完成的。</p>
<p>A service can essentially take two forms:</p>
<pre><code><span class="number">1.</span>started

A service is <span class="string">"started"</span> when <span class="operator">an</span> application component (such <span class="keyword">as</span> <span class="operator">an</span> activity) starts
<span class="keyword">it</span> <span class="keyword">by</span> calling startService(). Once started, <span class="operator">a</span> service can run <span class="operator">in</span> <span class="operator">the</span> background 
indefinitely, even <span class="keyword">if</span> <span class="operator">the</span> component that started <span class="keyword">it</span> is destroyed. Usually, <span class="operator">a</span> 
started service performs <span class="operator">a</span> single operation <span class="operator">and</span> does <span class="operator">not</span> <span class="constant">return</span> <span class="operator">a</span> <span class="built_in">result</span> <span class="built_in">to</span> <span class="operator">the</span>
 caller. For example, <span class="keyword">it</span> might download <span class="operator">or</span> upload <span class="operator">a</span> <span class="built_in">file</span> over <span class="operator">the</span> network. When
  <span class="operator">the</span> operation is done, <span class="operator">the</span> service should <span class="built_in">stop</span> itself.

<span class="number">2.</span>Bound

A service is <span class="string">"bound"</span> when <span class="operator">an</span> application component binds <span class="built_in">to</span> <span class="keyword">it</span> <span class="keyword">by</span> calling 
bindService(). A bound service offers <span class="operator">a</span> client-server interface that allows 
components <span class="built_in">to</span> interact <span class="operator">with</span> <span class="operator">the</span> service, <span class="built_in">send</span> requests, <span class="built_in">get</span> results, <span class="operator">and</span> even <span class="built_in">do</span>
 so across processes <span class="operator">with</span> interprocess communication (IPC). A bound service runs 
 only <span class="keyword">as</span> <span class="keyword">long</span> <span class="keyword">as</span> another application component is bound <span class="built_in">to</span> <span class="keyword">it</span>. Multiple 
 components can bind <span class="built_in">to</span> <span class="operator">the</span> service <span class="keyword">at</span> once, but when all <span class="operator">of</span> them unbind, <span class="operator">the</span> 
 service is destroyed.
</code></pre><p>1.started<br>    当一个application 组件通过调用start Service()启动service之后service处于“started”形式。一旦service启动，它将在无限的后台运行，即使触发service的组件已经被销毁。通常，一个started的形式的service执行单一操作，并且不返回结果给启动它的组件。for example，它可能从网络下载或者上传文件。当操作结束后，service应该结束掉它自己。<br>2.Bound<br>    当一个application组件通过调用bindService()使一个service处于“bound”形式。一个bound的service提供了一个C/S接口以完成application 组件和这个service的交互，send requests，getresults，甚至通过跨进成调度来通信。一个bound service只有在组件绑定它之后才可以运行。多个组件可以一次性绑定一个service，但是，当它们都取消绑定后，service将被销毁。</p>
<pre><code>Although this documentation generally discusses these two types <span class="keyword">of</span> services 
separately, your service can work both ways—<span class="keyword">it</span> can be started (<span class="keyword">to</span> <span class="command">run</span> 
indefinitely) <span class="keyword">and</span> also allow binding. It's simply a matter <span class="keyword">of</span> whether you 
implement a couple callback methods: onStartCommand() <span class="keyword">to</span> allow components <span class="keyword">to</span> 
start <span class="keyword">it</span> <span class="keyword">and</span> onBind() <span class="keyword">to</span> allow binding.

Regardless <span class="keyword">of</span> whether your <span class="type">application</span> <span class="keyword">is</span> started, bound, <span class="keyword">or</span> both, any 
<span class="type">application</span> component can use <span class="keyword">the</span> service (even <span class="keyword">from</span> a separate <span class="type">application</span>),
 <span class="keyword">in</span> <span class="keyword">the</span> same way <span class="keyword">that</span> any component can use an activity—<span class="keyword">by</span> starting <span class="keyword">it</span> <span class="keyword">with</span> an
  Intent. However, you can declare <span class="keyword">the</span> service <span class="keyword">as</span> private, <span class="keyword">in</span> <span class="keyword">the</span> manifest 
  <span class="type">file</span>, <span class="keyword">and</span> block access <span class="keyword">from</span> other applications. This <span class="keyword">is</span> discussed more <span class="keyword">in</span> <span class="keyword">the</span> 
  section <span class="keyword">about</span> Declaring <span class="keyword">the</span> service <span class="keyword">in</span> <span class="keyword">the</span> manifest.
</code></pre><p>这两段比价简单，只需要注意一下在manifest中声明service为你的application私有就好了。</p>
<pre><code>Caution: A service runs <span class="keyword">in</span> <span class="keyword">the</span> main thread <span class="keyword">of</span> <span class="keyword">its</span> hosting process—<span class="keyword">the</span> service 
<span class="keyword">does</span> <span class="keyword">not</span> create <span class="keyword">its</span> own thread <span class="keyword">and</span> <span class="keyword">does</span> <span class="keyword">not</span> <span class="command">run</span> <span class="keyword">in</span> a separate process (unless 
you specify otherwise). This means <span class="keyword">that</span>, <span class="keyword">if</span> your service <span class="keyword">is</span> going <span class="keyword">to</span> do any CPU 
intensive work <span class="keyword">or</span> blocking operations (such <span class="keyword">as</span> MP3 playback <span class="keyword">or</span> networking), you
 should create a new thread within <span class="keyword">the</span> service <span class="keyword">to</span> do <span class="keyword">that</span> work. By using a 
 separate thread, you will reduce <span class="keyword">the</span> risk <span class="keyword">of</span> Application Not Responding (ANR)
  errors <span class="keyword">and</span> <span class="keyword">the</span> <span class="type">application</span>'s main thread can remain dedicated <span class="keyword">to</span> user 
  interaction <span class="keyword">with</span> your activities.
</code></pre><p>慎重处理：一个service运行在当前进程的主线程中，service不能为自己创建线程也不能在另外的进程运行。这就意味着，如果你的service将要执行一些CPU密集型操作，或者线程阻塞操作(such as MP3 playback or networking),你应该新建一个包含该service的线程来执行此类操作。通过使用另一个线程，你的application将减少了引发ANR错误的可能性，并且你的主线程将保留这来进行与用户的交互活动。</p>
<hr>
<p>延伸阅读 :Should you use a service or a thread?</p>
<pre><code>A service <span class="keyword">is</span> simply a component <span class="keyword">that</span> can <span class="command">run</span> <span class="keyword">in</span> <span class="keyword">the</span> background even when <span class="keyword">the</span> 
user <span class="keyword">is</span> <span class="keyword">not</span> interacting <span class="keyword">with</span> your <span class="type">application</span>. Thus, you should create a 
service only <span class="keyword">if</span> <span class="keyword">that</span> <span class="keyword">is</span> what you need.

If you need <span class="keyword">to</span> perform work outside your main thread, <span class="keyword">but</span> only <span class="keyword">while</span> <span class="keyword">the</span> user 
<span class="keyword">is</span> interacting <span class="keyword">with</span> your <span class="type">application</span>, <span class="keyword">then</span> you should probably instead create a 
new thread <span class="keyword">and</span> <span class="keyword">not</span> a service. For example, <span class="keyword">if</span> you want <span class="keyword">to</span> play <span class="keyword">some</span> music, <span class="keyword">but</span> 
only <span class="keyword">while</span> your activity <span class="keyword">is</span> <span class="property">running</span>, you might create a thread <span class="keyword">in</span> onCreate(), 
start <span class="property">running</span> <span class="keyword">it</span> <span class="keyword">in</span> onStart(), <span class="keyword">then</span> stop <span class="keyword">it</span> <span class="keyword">in</span> onStop(). Also consider using 
AsyncTask <span class="keyword">or</span> HandlerThread, <span class="keyword">instead of</span> <span class="keyword">the</span> traditional Thread <span class="type">class</span>. See <span class="keyword">the</span>
 Processes <span class="keyword">and</span> Threading document <span class="keyword">for</span> more information <span class="keyword">about</span> threads.

Remember <span class="keyword">that</span> <span class="keyword">if</span> you do use a service, <span class="keyword">it</span> still runs <span class="keyword">in</span> your <span class="type">application</span>'s main
 thread <span class="keyword">by</span> default, so you should still create a new thread within <span class="keyword">the</span> service 
 <span class="keyword">if</span> <span class="keyword">it</span> performs intensive <span class="keyword">or</span> blocking operations.
</code></pre><p>有了前面的铺垫，相比此处很容易裂理解吧，贴出来只是为了大家使用thread和service更容易的思考和抉择。</p>
<hr>
<p>好，现在来看一下Service的生命周期：</p>
<p><img src="http://cl.ly/image/2X1O1j2H033l/service_lifecycle.png" alt="Alt text"></p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

 android.app.Service;
<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.content.res.Configuration;
<span class="keyword">import</span> android.os.IBinder;

<span class="keyword">import</span> java.io.FileDescriptor;
<span class="keyword">import</span> java.io.PrintWriter;

<span class="javadoc">/**
 * Created by canglangwenyue on 12/7/14.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>{
<span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onCreate();
     Notification notification = <span class="keyword">new</span> Notification(R.drawable.ic_launcher, getText(R.string.app_name),
            System.currentTimeMillis());
    Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);
    notification.setLatestEventInfo(<span class="keyword">this</span>, getText(R.string.hello_world),
            getText(R.string.hello_world), pendingIntent);
    startForeground(<span class="number">1</span>, notification);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>{
    <span class="keyword">super</span>.onStart(intent, startId);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onStartCommand</span><span class="params">(intent, flags, startId)</span></span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onDestroy();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>{
    <span class="keyword">super</span>.onConfigurationChanged(newConfig);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>{
    <span class="keyword">super</span>.onLowMemory();
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>{
    <span class="keyword">super</span>.onTrimMemory(level);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function">IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>{
    <span class="keyword">return</span> <span class="keyword">null</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>{
    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onUnbind</span><span class="params">(intent)</span></span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onRebind</span><span class="params">(Intent intent)</span> </span>{
    <span class="keyword">super</span>.onRebind(intent);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTaskRemoved</span><span class="params">(Intent rootIntent)</span> </span>{
    <span class="keyword">super</span>.onTaskRemoved(rootIntent);
}

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter writer, String[] args)</span> </span>{
    <span class="keyword">super</span>.dump(fd, writer, args);
}
    }
</code></pre><p>记得在manifest文件里注册service，</p>
<p><img src="http://cl.ly/3y110Y3u3B2O/registerservice.tiff" alt="Alt text"></p>
<p>可以在onCreate()方法中启动一个notification，是你的service显示在通知栏，当然这里只是简单的显示，具体可可以做更多的工作。然后在需要启动service的activity里面用</p>
<pre><code><span class="type">Intent</span> <span class="type">intent</span> = new <span class="type">Intent</span>(this,MyService.<span class="keyword">class</span>);

startService(<span class="type">intent</span>);
</code></pre><p>来开始一个 service。</p>
<hr>
<p>好了，既然Service已经写到这种程度了，那么我们就再接再厉来看看IntentService吧，并比较一下如何在service与IntentService之间抉择，让大家更好地理解。</p>
<pre><code>Service

This <span class="keyword">is</span> the base <span class="keyword">class</span> <span class="keyword">for</span> all services. <span class="keyword">When</span> you extend this <span class="keyword">class</span>, it<span class="comment">'s </span>
important that you create a <span class="keyword">new</span> thread <span class="keyword">in</span> which <span class="keyword">to</span> <span class="keyword">do</span> all the service<span class="comment">'s work, </span>
because the service uses your application<span class="comment">'s main thread, by default, which </span>
could slow the performance <span class="keyword">of</span> any activity your application <span class="keyword">is</span> running.
IntentService

This <span class="keyword">is</span> a subclass <span class="keyword">of</span> Service that uses a worker thread <span class="keyword">to</span> handle all start 
requests, one at a time. This <span class="keyword">is</span> the best <span class="keyword">option</span> <span class="keyword">if</span> you don<span class="comment">'t require that your </span>
service handle multiple requests simultaneously. All you need <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">is</span> 
implement onHandleIntent(), which receives the intent <span class="keyword">for</span> <span class="keyword">each</span> start request so 
you can <span class="keyword">do</span> the background work.
</code></pre><p>Service </p>
<pre><code>这是所有services的基类。当你extendsService之后，你是在你的application的<span class="keyword">main</span> thread中创建了一个用于执行所有<span class="keyword">service</span><span class="string">'s work的新线程，默认的，这种行为会降低你的activity正在执行的任何activity的性能。</span>
</code></pre><p>IntentService</p>
<pre><code>IntentService是Service类的子类，它用一个工作线程来处理所有的requests，而且一次只能执行一个。如果你不要求你的Service同时执行多个请求，那么IntentService便是最好的选择。你所需要做的只是实现<span class="function"><span class="title">onHandleIntent</span><span class="params">()</span></span>，<span class="function"><span class="title">onHandleIntent</span><span class="params">()</span></span>用来接收每个请求并在后台工作。使用Service使必须另开线程，而使用IntentService则不需要，因为framework默认实现了一个worker thread。IntentService自己维护了一个队列，他会一个接一个的处理request。
</code></pre><p>好了，那么来看一下，官网上IntentService的实现：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HelloIntentService</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">IntentService</span> {</span>

  <span class="comment">/** 
   * A constructor is required, and must call the super IntentService(String)
   * constructor with a name for the worker thread.
   */</span>
  public <span class="type">HelloIntentService</span>() {
      <span class="keyword">super</span>(<span class="string">"HelloIntentService"</span>);
  }

  <span class="comment">/**
   * The IntentService calls this method from the default worker thread with 
   * the intent that started the service. When this method returns, IntentService
   * stops the service, as appropriate.
   */</span>
  <span class="annotation">@Override</span>
  <span class="keyword">protected</span> void onHandleIntent(<span class="type">Intent</span> intent) {
  <span class="comment">// Normally we would do some work here, like download a file.</span>
  <span class="comment">// For our sample, we just sleep for 5 seconds.</span>
  long endTime = <span class="type">System</span>.currentTimeMillis() + <span class="number">5</span>*<span class="number">1000</span>;
      <span class="keyword">while</span> (<span class="type">System</span>.currentTimeMillis() &lt; endTime) {
          synchronized (<span class="keyword">this</span>) {
              <span class="keyword">try</span> {
                  wait(endTime - <span class="type">System</span>.currentTimeMillis());
              } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
              }
          }
      }
  }
}
</code></pre><p>好了，现在应该是很简单了，有木有。注意IntentService一般和LocalBroadcastManager组合使用，从而使得IntentService将任务执行的任务状态与结果返回给任务的发送方。</p>
<p>官方文档地址：</p>
<p><a href="http://developer.android.com/guide/components/services.html#Basics" target="_blank" rel="external">API Guides</a></p>
<p><a href="http://developer.android.com/reference/android/app/Service.html" target="_blank" rel="external">Reference</a></p>
<p>嗯嗯，就写到这里了。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/07/android-service完全解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/07/android-service完全解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/07/android-service完全解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-05T06:26:01.000Z"><a href="/2014/12/05/javalangcloneable解析/">周五, 12月 5 2014, 2:26:01 下午</a></time>

  
    <h1 class="title"><a href="/2014/12/05/javalangcloneable解析/">java.lang.Cloneable解析</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/java/">java</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>java.lang<br>Interface Cloneable</p>
<p>All Known Subinterfaces:<br>所有已知的子接口</p>
<pre><code>AclEntry, Attribute, AttributedCharacterIterator, Attributes, CertPathBuilderResult,CertPathParameters, CertPathValidatorResult, CertSelector,
 CertStoreParameters, CharacterIterator, CRLSelector, Descriptor, GSSCredential,
  <span class="keyword">Name</span>
</code></pre><p>public interface Cloneable</p>
<pre><code>A class implements the <span class="type">Cloneable</span> <span class="keyword">interface</span> to indicate to the <span class="type">Object</span>.clone() 
<span class="keyword">method</span> that it <span class="keyword">is</span> legal <span class="keyword">for</span> that <span class="keyword">method</span> to make a field-<span class="keyword">for</span>-field copy <span class="keyword">of</span> 
instances <span class="keyword">of</span> that class.

<span class="type">Invoking</span> <span class="type">Object</span>'s clone <span class="keyword">method</span> on an instance that does <span class="keyword">not</span> implement the 
<span class="type">Cloneable</span> <span class="keyword">interface</span> results <span class="keyword">in</span> the exception <span class="type">CloneNotSupportedException</span> being 
thrown.

<span class="type">By</span> convention, classes that implement this <span class="keyword">interface</span> should override <span class="type">Object</span>.clone
 (which <span class="keyword">is</span> protected) <span class="keyword">with</span> a public <span class="keyword">method</span>. <span class="type">See</span> <span class="type">Object</span>.clone() <span class="keyword">for</span> details on
  overriding this <span class="keyword">method</span>.

<span class="type">Note</span> that this <span class="keyword">interface</span> does <span class="keyword">not</span> contain the clone <span class="keyword">method</span>. <span class="type">Therefore</span>, it <span class="keyword">is</span> <span class="keyword">not</span>
 possible to clone an <span class="keyword">object</span> merely by virtue <span class="keyword">of</span> the fact that it implements this 
 <span class="keyword">interface</span>. <span class="type">Even</span> <span class="keyword">if</span> the clone <span class="keyword">method</span> <span class="keyword">is</span> invoked reflectively, there <span class="keyword">is</span> no 
 guarantee that it will succeed.
</code></pre><p>此类实现了Cloneable interface以表明Object.clone() 方法可以以合法的方式对该class的实例进行复制。</p>
<p>如果调用clone method方法的实例没有implements Cloneable接口，那么会抛出CloneNotSupportedException Exception。</p>
<p>按照习惯，implements了Cloneable接口的classes需要重载Object.clone(它是protected)。</p>
<p>注意，这个interface不包含clone method。因此，某个对象实现了它就clone是不可能的。即使反射调用clone method，也不会保证该调用会成功。</p>
<p>Since:<br>JDK1.0<br>See Also:<br>CloneNotSupportedException, Object.clone()</p>
<hr>
<p>以上直接翻译自java doc，想必已经很清楚了吧。接下来，技改出一个简单的例子，来记录一下。</p>
<pre><code><span class="comment">/**
 * Created by canglangwenyue on 12/5/14.
 */</span>
<span class="keyword">public</span> class Person implements Cloneable {

    <span class="keyword">private</span> <span class="built_in">int</span> id;
    <span class="keyword">private</span> <span class="keyword">String</span> name;

    <span class="keyword">public</span> <span class="keyword">String</span> getName() {
    <span class="keyword">return</span> name;
    }

    <span class="keyword">public</span> <span class="built_in">int</span> getId() {
    <span class="keyword">return</span> id;
    }

    <span class="keyword">public</span> <span class="keyword">void</span> setId(<span class="built_in">int</span> id) {
    <span class="keyword">this</span>.id = id;
    }

        <span class="keyword">public</span> <span class="keyword">void</span> setName(<span class="keyword">String</span> name) {
    <span class="keyword">this</span>.name = name;
        }

    @Override
    <span class="keyword">protected</span> <span class="keyword">Object</span> clone() {

    Person <span class="built_in">copy</span> = <span class="keyword">null</span>;

    <span class="keyword">try</span> {
        <span class="built_in">copy</span> = (Person) <span class="keyword">super</span>.clone();
        <span class="built_in">copy</span>.clone().getClass().getName();

    } <span class="keyword">catch</span> (CloneNotSupportedException e) {
        e.printStackTrace();
    } <span class="keyword">finally</span> {
        <span class="keyword">return</span> <span class="built_in">copy</span>;
    }


        }

        @Override
    <span class="keyword">public</span> <span class="built_in">boolean</span> equals(<span class="keyword">Object</span> obj) {
    <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);
    }

    <span class="comment">/**
     * 引用复制的测试
     */</span>

        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> referenceTest() {
    Person person = <span class="keyword">new</span> Person();

    person.setId(<span class="number">1</span>);
    person.setName(<span class="string">"WenYue"</span>);

    Person <span class="built_in">copy</span> = person;

    <span class="keyword">if</span> (<span class="built_in">copy</span>.equals(person))
        System.out.<span class="built_in">println</span>(<span class="string">"引用复制的person和copy是同一个对象"</span>);
    <span class="keyword">else</span>
        System.out.<span class="built_in">println</span>(<span class="string">"引用复制的person和copy不是同一个对象"</span>);

    System.out.<span class="built_in">println</span>(person);
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>);
    System.out.<span class="built_in">println</span>(person.getName());
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>.getName());

        }

    <span class="comment">/**
     * 对于Object的clone的测试方法，并检测出clone实现的是浅拷贝
     */</span>
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> cloneTest(){
    Person person = <span class="keyword">new</span> Person();

    person.setId(<span class="number">1</span>);
    person.setName(<span class="string">"WenYue"</span>);

    Person <span class="built_in">copy</span> = <span class="keyword">null</span>;

    <span class="built_in">copy</span> = (Person) person.clone();

    <span class="keyword">if</span> (<span class="built_in">copy</span>.equals(person))
        System.out.<span class="built_in">println</span>(<span class="string">"clone的person和copy是同一个对象"</span>);
    <span class="keyword">else</span>
        System.out.<span class="built_in">println</span>(<span class="string">"clone的person和copy不是同一个对象"</span>);

    System.out.<span class="built_in">println</span>(person);
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>);
    System.out.<span class="built_in">println</span>(person.getName());
    System.out.<span class="built_in">println</span>(<span class="built_in">copy</span>.getName());

    <span class="keyword">String</span> result = person.getName()==<span class="built_in">copy</span>.getName()?<span class="string">"clone是浅拷贝"</span>:<span class="string">"clone是深拷贝"</span>;
    System.out.<span class="built_in">println</span>(result);
        }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
    <span class="comment">/*测试clone*/</span>
    cloneTest();

    <span class="comment">/*测试引用复制*/</span>
    referenceTest();

    }


    }
</code></pre><p>给出main函数的执行结果：</p>
<p><img src="http://cl.ly/1K3b3B1E0G1S/ObjectClone.tiff" alt="Alt text"></p>
<p>好了，现在来解释一下这段测试代码。</p>
<p>可以看到main函数中执行了两个测试方法，cloneTest()和referenceTest();第一个实现了Cloneable interface后的Object进行clone() method的测试；而之所以添加第二个method的原因是将对象的浅拷贝，即clone(java 中默认对象的拷贝是浅拷贝)。，与引用的复制进行对比，便于大家理解。</p>
<pre><code><span class="number">1.</span>从这段代码的执行结果中可以清晰地看到，clone实现的<span class="keyword">copy</span>为<span class="keyword">copy</span>创建了新对象(在内存中的地址不同)，而<span class="keyword">reference</span>的复制，只是把原对象的地址复制给了新对象，所以直行后，person和<span class="keyword">copy</span>指向了相同的地址空间。
</code></pre><p>关于clone默认是浅拷贝的解释</p>
<pre><code><span class="number">2</span>. 首先，由于id是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个<span class="number">4</span>字节的整数值拷贝过来就行。但是name是<span class="type">String</span>类型的，而且name只是一个引用，指向真正的<span class="type">String</span>对象，之所以说clone默认是浅拷贝的原因就是，在clone时clone方法只是把<span class="type">String</span>对象的引用值拷贝给了新的copy对象的name字段；而并非在内存中重新创建一个<span class="type">String</span>对象，并让copy对象的name字段的引用指向它。证明如下：

 <span class="type">String</span> <span class="literal">result</span> = person.getName()==copy.getName()?<span class="string">"clone是浅拷贝"</span>:<span class="string">"clone是深拷贝"</span>;
首先请大家看着行代码，大概意思是若二者在内存中的地址相同，则返回<span class="string">"clone是浅拷贝"</span>，而内存中的地址空间是否相同便可以判断是否是同一个对象。

<span class="number">3</span>.正如前面文档解释的implements了<span class="type">Cloneable</span>接口的classes需要重载<span class="type">Object</span>.clone。
</code></pre><p>这里挖个坑吧，关于深拷贝的仔细研究，我就在之后来填。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/05/javalangcloneable解析/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/05/javalangcloneable解析/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/05/javalangcloneable解析/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-05T01:16:06.000Z"><a href="/2014/12/05/androidosparcelable文档自译/">周五, 12月 5 2014, 9:16:06 上午</a></time>

  
    <h1 class="title"><a href="/2014/12/05/androidosparcelable文档自译/">android.os.Parcelable文档自译</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>android.os.Parcelable接口的已知间接子类很多，这里就不列举了：</p>
<pre><code><span class="keyword">Class</span> Overview

<span class="keyword">Interface</span> <span class="keyword">for</span> classes whose instances can be written <span class="keyword">to</span> <span class="keyword">and</span> restored <span class="keyword">from</span> a 
Parcel. Classes implementing the Parcelable <span class="keyword">interface</span> must also have a <span class="keyword">static</span> 
field called CREATOR, which <span class="keyword">is</span> an <span class="built_in">object</span> implementing the Parcelable.Creator 
<span class="keyword">interface</span>.
</code></pre><p>该Interface用于实例可以被写入，并且可以从Parcel中恢复的classes(对于Parcel暂时只要知道它是一个存<br>放数据的容器就好了，我会在android IPC中写到它)。实现android.os.Parcelable接口的类必须持有一个实<br>现了android.os.Parcelable接口的名为 CREATOR 的静态字段。</p>
<p>android.os.Parcelable接口典型使用方式,这是官网的例子：</p>
<pre><code>package me.androiddemo.canglangwenyue.androiddemo;

import android.os.Parcel;
import android.os.Parcelable;

<span class="comment">/**
 * Created by canglangwenyue on 12/5/14.
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyParcelable</span> <span class="title">implements</span> <span class="title">Parcelable</span> {
<span class="keyword">private</span> <span class="keyword">int</span> mData;

<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel <span class="keyword">out</span>, <span class="keyword">int</span> flags)</span> </span>{
    <span class="keyword">out</span>.writeInt(mData);
}

<span class="keyword">public</span> <span class="keyword">static</span> final Parcelable.Creator&lt;MyParcelable&gt; CREATOR
        = <span class="keyword">new</span> Parcelable.Creator&lt;MyParcelable&gt;() {
    <span class="function"><span class="keyword">public</span> MyParcelable <span class="title">createFromParcel</span><span class="params">(Parcel <span class="keyword">in</span>)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable(<span class="keyword">in</span>);
    }

    <span class="keyword">public</span> MyParcelable[] newArray(<span class="keyword">int</span> size) {
        <span class="keyword">return</span> <span class="keyword">new</span> MyParcelable[size];
    }
};

<span class="function"><span class="keyword">private</span> <span class="title">MyParcelable</span><span class="params">(Parcel <span class="keyword">in</span>)</span> </span>{
    mData = <span class="keyword">in</span>.readInt();
}
}
</code></pre><p>Summary(简介)</p>
<p>Nested Classes(嵌套类)    </p>
<pre><code><span class="number">1.</span><span class="keyword">interface</span>    Parcelable.ClassLoaderCreator&lt;T&gt;
    Specialization <span class="keyword">of</span> Parcelable.Creator that allows you <span class="keyword">to</span> receive
    the ClassLoader the <span class="built_in">object</span> <span class="keyword">is</span> being created <span class="keyword">in</span>.

解析：专业化的 Parcelable.Creator，允许你接收的<span class="built_in">Object</span>内部创建的 ClassLoader 对象. 

<span class="number">2.</span><span class="keyword">interface</span>    Parcelable.Creator&lt;T&gt;     
<span class="keyword">Interface</span> that must be implemented <span class="keyword">and</span> provided <span class="keyword">as</span> a <span class="keyword">public</span> CREATOR field that
 generates instances <span class="keyword">of</span> your Parcelable <span class="keyword">class</span> <span class="keyword">from</span> a Parcel. 
 解析：该接口必须被子类实现，而且CREATOR 作为公有字段来提供，CREATOR 用于从 Parcel中实例化你的可包装类.
</code></pre><p>Constants(常量)</p>
<pre><code>1.int    CONTENTS_FILE_DESCRIPTOR     
Bit masks for <span class="operator"><span class="keyword">use</span> <span class="keyword">with</span> describeContents(): <span class="keyword">each</span> <span class="built_in">bit</span> represents a kind <span class="keyword">of</span> object
 considered <span class="keyword">to</span> have potential special significance <span class="keyword">when</span> marshalled.

解析：用于 describeContents() 的位掩码，每一位代表它编组时附加的特殊含义。

<span class="number">2.</span><span class="built_in">int</span>    PARCELABLE_WRITE_RETURN_VALUE     
Flag <span class="keyword">for</span> <span class="keyword">use</span> <span class="keyword">with</span> writeToParcel(Parcel, <span class="built_in">int</span>): the object being written <span class="keyword">is</span> a 
<span class="keyword">return</span> <span class="keyword">value</span>, that <span class="keyword">is</span> the result <span class="keyword">of</span> a <span class="keyword">function</span> such <span class="keyword">as</span> <span class="string">"Parcelable 
someFunction()"</span>, <span class="string">"void someFunction(out Parcelable)"</span>, <span class="keyword">or</span> <span class="string">"void 
someFunction(inout Parcelable)"</span>.

解析：writeToParcel(Parcel, <span class="built_in">int</span>)的标志位：作为一个返回值，是<span class="string">"Parcelable 
someFunction()"</span>, <span class="string">"void someFunction(out Parcelable)"</span>, <span class="keyword">or</span> <span class="string">"void 
someFunction(inout Parcelable)"</span>返回的result。</span>
</code></pre><p>Public Methods(公共method)</p>
<pre><code><span class="number">1.</span><span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span>     <span class="title">describeContents</span><span class="params">()</span>
Describe the kinds of special objects contained <span class="keyword">in</span> <span class="keyword">this</span> Parcelable's marshalled
 representation.

 解析：描述各种特殊对象，它们包含在可包装对象的编组形式中.

2.<span class="keyword">abstract</span> <span class="keyword">void</span>     <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span>
Flatten <span class="keyword">this</span> <span class="keyword">object</span> <span class="keyword">in</span> to a Parcel.

解析：将该对象展开到<span class="title">Parcel</span><span class="params">(存放数据的容器)</span>中。</span>
</code></pre><p>Parcelable适用于通过Intent来传递自定义对象。最后给出一个用Parcelable进行数据传送的例子</p>
<p>1.发送Object的Activity，内容很简单，点击Button，Intent携带Object跳转到MainActivity2(用来接收Object的Activity)。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.widget.Button;

<span class="keyword">import</span> java.util.HashMap;

<span class="javadoc">/**
 *<span class="javadoctag"> @author</span> canglangwenyue
 * 用来发送信息的Activity
 */</span>

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ActionBarActivity</span> </span>{

<span class="keyword">private</span> Button sendButton;

<span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    sendButton = (Button) findViewById(R.id.send_button);

    sendButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {
        <span class="annotation">@Override</span>
        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
            Intent intent = <span class="keyword">new</span> Intent();
            Person person = <span class="keyword">new</span> Person();

            person.name = <span class="string">"WenYue"</span>;
            intent.putExtra(<span class="string">"WenYue"</span>,person);
            intent.setClass(MainActivity.<span class="keyword">this</span>,MainActivity2.class);

            startActivity(intent);
        }
    });

}


<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>{
    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
    getMenuInflater().inflate(R.menu.menu_main, menu);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>{
    <span class="comment">// Handle action bar item clicks here. The action bar will</span>
    <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
    <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
    <span class="keyword">int</span> id = item.getItemId();

    <span class="comment">//noinspection SimplifiableIfStatement</span>
    <span class="keyword">if</span> (id == R.id.action_settings) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onOptionsItemSelected</span><span class="params">(item)</span></span>;
}
}
</code></pre><p>2.MainActivity2用来接收来自MainActivity的Object，并打印Person.name的长度和content。</p>
<pre><code>package me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.content.Intent;
<span class="keyword">import</span> android.support.v7.app.ActionBarActivity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.util.Log;
<span class="keyword">import</span> android.view.Menu;
<span class="keyword">import</span> android.view.MenuItem;

<span class="comment">/**</span>
</code></pre><ul>
<li>@author canglangwenyue</li>
<li><p>接收数据的Intent<br>  */</p>
<p> public class MainActivity2 extends ActionBarActivity {</p>
<p> @Override<br> protected void onCreate(Bundle savedInstanceState) {</p>
<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main_activity2);

Intent intent = getIntent();

Person person = intent.getParcelableExtra(<span class="string">"WenYue"</span>);

<span class="keyword">Log</span>.<span class="literal">e</span>(<span class="string">"MainActivity2 received message's length-----&gt;"</span>,String.valueOf(person.name.<span class="literal">length</span>()));
<span class="keyword">Log</span>.<span class="literal">e</span>(<span class="string">"MainActivity2 received message content------&gt;"</span>,person.name);
</code></pre><p> }</p>
</li>
</ul>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>{
    <span class="comment">// Inflate the menu; this adds items to the action bar if it is present.</span>
    getMenuInflater().inflate(R.menu.menu_main_activity2, menu);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>{
    <span class="comment">// Handle action bar item clicks here. The action bar will</span>
    <span class="comment">// automatically handle clicks on the Home/Up button, so long</span>
    <span class="comment">// as you specify a parent activity in AndroidManifest.xml.</span>
    <span class="keyword">int</span> id = item.getItemId();

    <span class="comment">//noinspection SimplifiableIfStatement</span>
    <span class="keyword">if</span> (id == R.id.action_settings) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onOptionsItemSelected</span><span class="params">(item)</span></span>;
}
}
</code></pre><p>3.Parcelable的实现，具体细节前面已经讲到了，就不多说了。</p>
<pre><code><span class="keyword">package</span> me.androiddemo.canglangwenyue.androiddemo;

<span class="keyword">import</span> android.os.Parcel;
<span class="keyword">import</span> android.os.Parcelable;

<span class="javadoc">/**
 * Created by canglangwenyue on 12/5/14.
 * Parcelable常用于Intent中进行自定义对象的传递
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>{


<span class="keyword">public</span> String name;

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>{
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="annotation">@Override</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>{

    dest.writeString(name);

}

<span class="comment">/*
需要重写Creator实现android.os.Parcelable接口的类必须持有一个实现了android.os.Parcelable接口的名为 CREATOR 的静态字段
 */</span>

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;() {

    <span class="comment">/*
    重写Creator方法
     */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>{
        Person person = <span class="keyword">new</span> Person();
        person.name = source.readString();
        <span class="keyword">return</span> person;
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) {
        <span class="keyword">return</span> <span class="keyword">new</span> Person[<span class="number">0</span>];
    }

};

}
</code></pre><p>最后给出在MainActivity2中log打印的结果，眼见为实，哈哈：</p>
<p><img src="http://cl.ly/image/0n1T2a3Y443M/Parcelable.png" alt="Alt text"></p>
<p>再附上demo下载地址，希望对大家与帮助：<br><a href="http://download.csdn.net/detail/u010835702/8227511" target="_blank" rel="external">苍狼问月</a></p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/05/androidosparcelable文档自译/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/05/androidosparcelable文档自译/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/05/androidosparcelable文档自译/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-12-03T08:46:40.000Z"><a href="/2014/12/03/写给我两年零三个月的大学生活/">周三, 12月 3 2014, 4:46:40 下午</a></time>

  
    <h1 class="title"><a href="/2014/12/03/写给我两年零三个月的大学生活/">写给我两年零三个月的大学生活</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/点滴/">点滴</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>感觉现在自己很浮躁呢，静下心来真心不容易啊。感觉自己大学两年多过的有点稀里糊涂的。现在感觉终于静下来了，就写点什么吧，权当是对过往的总结和对未来的展望吧。</p>
<p>回想自刚踏入大学的那个一无所知的懵懂少年，到现在心沉如水的油条，辩护不可谓不大啊。大一第一学期的时候，自己真心一无所知，也没人指点。所以就兴冲冲的想要好好体验一下象牙塔的生活，于是学生会，团委，辩论队。。。傻傻的参加了一大堆社团面试，出乎意外的竟然通过了。于是，整日奔波于各个社团之间。就这样，一学期过去了。现在回想起来，我大学的第一学期当真是过的苍白无力啊。</p>
<p>接着，来到了大一第二学习。在这个学期，我开始慢慢放弃了那些热闹却对自己的未来发展作用不大的社团(PS:我是做技术的)。所以可能会有些认知不全吧，勿喷。在这个学习我开始计划自己学一些技术方面东西。但是，碍于自己毫无基础，而且上大学之前对计算机领域几乎小白，所以，当真不知该如何下手呢。记得，当时学校在将数据结构，于是我就抱本书在那里啃。最后自己试着用C语言写了一个学生信息管理系统，这本来是学校大作业来的，我们组的作业我一个人做了。学生信息管理系统，很土，有木有!!!!!!!!!不过，这确实我有史以来的第一个个人项目。是它让我更好的学习了C语言，也让我在技术学习之路上有了一丝自信。我开始相信，只要自己肯努力，永远都不算晚。纵使发白如雪，亦有朝夕可争！！！</p>
<p>大一结束之后，我突然有了一种怅然若失的感觉。经历了一年，分化已经很明显。学霸已经浮出水面，学渣也是若影若现。而我，既不是学霸，也不是学渣。因为我没拿到奖学金，也没有沦为坐末班车的学生。也是，我开始思考，是好好学习，去冲击学霸之位呢？还是另谋出路？经过我的冷静思考，我决定向技术指路发展，因为我个人认为为了考大学，我已经在书本里泡了十二年，到了大学还要为了学霸之位去学习那些与我未来而言并无多大用处的毛概，电路啥的。却也是无奈的紧。于是，那个假期我在学校留了二十天，自己自学了java，和入门android开发。这是我才发现当时在C语言和数据结构上的投入时多么的值得。</p>
<p>大二第一学期，我成长了很多，不仅技术方面，而且在心智和对未来的思考上都有了比较成熟的认识。这着一学期，我做了两个项目，都是用来参加比赛的，一个是嵌入式相关的，一个是android的app，参加比赛也取得了不错的结局。就这样，一学期过去了。</p>
<p>大二第二学期，对我来说是一个比较大的转折，在这个学期伊始，有学长带我一起做了个外包android app。时至今日，我仍旧非常感谢，虽然我当时做的只是一些打杂的工作，不过，却也是让我体会到了团队开发的乐趣,这次真心拓宽了我的视野。之后的日子里，因为参加比赛的原因，我开始学习java web方面的知识。同时我真的意识到，好队友的重要性。如果你能遇到一个好队友，那么感谢上天对你的怜爱吧；如果遇到傻逼队友就只能呵呵了，默默接着就是了。</p>
<p>大二假期，我在学院研究所跟一位老师做web项目，算是学习吧，不过老师也对我很好，给了我三千RMB，按理说学生帮老师做东西不给钱都是正常的，至少在中国是这样。这个项目是javaweb方面的，和硬件有交集，我独自昨完成了数据接收与解析，数据库设计，以及前端功能的简单实现。然后就开学了。</p>
<p>现在的我，但三第一学期就剩一百多天了，向下学期去找实习，却始终觉得自己能力不足。在大三过去的这段时间里我自己完成了一个比赛的web部分；另外，用不到两周时间写了个简单的web加app的项目。设计+app代码实现+server都是我自己一个人写的。最近上传到了小米商店。大概六天了吧，应该有好几百次下载了，也不知道这算好还是不好。。</p>
<p>之所以写这篇文章呢，就当是对自己的总结。记得有句话，意思大概是:”当你站的越高，看到的风景也会更美，但是压力必然会增大”。最近遇到了一些和我年纪相仿的小伙伴们，都是很牛逼的。这让我感到了压力，但却有了更多向前的动力。一直都喜欢看超人前传，我至少看了两遍了吧。喜欢他是因为看到超人不断成长的力量。我向往和羡慕他那种可以突破天际的的力量，那种完全掌控自己命运的绝对力量。所以，我希望在我在生命里的一天，可以通过自己的努力，为自己做出很大的改变。</p>
<p>最后，写一下自己的简单经历吧。目前做过4个android app，其中一个是嵌入式相关的，另一个是基于位置信息的，只两个都是参加比赛的，结果还不错吧；第三个，是一个外包，那个学长带我一起做的，挣了2800吧，算是我大学的第一桶金，但却不是我人生的第一桶金，我人生的第一桶金是高考结束后办辅导班，当时挣钱不少呢，哈哈。最后一个就是最近做的app加server。接近两周的课余时间吧，已经上线了。然后，就是两个web项目，一个是比赛用的，另一个就是和替我教授做的一个公司的web项目，也是挣了三千块钱。嗯，大概就这些吧，很怀疑这样的简历，下学期能不能找到实习啊？？？</p>
<p>现在我觉得自己虽然学过也用过比较多的东西了，但是很多东西都是知其然不知其所以然。。都是看文章，看手册，查资料，感觉除了写代码的感觉之外，对自己并没有太大的提升，这样的我始终缺乏核心竞争力吧。所以，我想就目前而言，我对android的还是给常感兴趣的，自从自己可战server与web之后，感觉想做东西时再也不用束手束脚了。所以，我计划在接下来的日子里好好研究下android，而不是只做一个coder，然后完善与维护现在上线的那个app，就当是积累经验吧。</p>
<p>写在最后，感觉大学伊始，若是有人指点一下，对于迷茫的人而言是一件很幸运的事呢；但是，只要你想改变自己，即使没人指点，只要你努力，虽然会慢点，但你终究会摸索出一条属于自己的路，只要坚持下去，你总会离自己的目标也来越近，越来越近。用我最喜欢的那句话结束这篇牢骚文吧:”他年我若为青帝，抱死桃花一处开”。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/12/03/写给我两年零三个月的大学生活/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/12/03/写给我两年零三个月的大学生活/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/12/03/写给我两年零三个月的大学生活/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-11-30T07:33:49.000Z"><a href="/2014/11/30/android-saveinstancestate/">周日, 11月 30 2014, 3:33:49 下午</a></time>

  
    <h1 class="title"><a href="/2014/11/30/android-saveinstancestate/">Android saveInstanceState</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>以前一直对onCreate(Bundle saveInstanceState)的参数不知其意，今天特地研究了一下，记录于此。</p>
<p>与此相关的有两个method：</p>
<pre><code> <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="comment">// Save away the original text, so we still have it if the activity</span>
    <span class="comment">// needs to be killed while paused.</span>
    savedInstanceState.putInt(<span class="string">"IntTest"</span>, <span class="number">0</span>);
    savedInstanceState.putString(<span class="string">"StrTest"</span>, <span class="string">"savedInstanceState test"</span>);
    <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);
    Log.e(TAG, <span class="string">"使用了我的onSaveInstanceState"</span>);
}

<span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>{
    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);
    <span class="keyword">int</span> IntTest = savedInstanceState.getInt(<span class="string">"IntTest"</span>);
    String StrTest = savedInstanceState.getString(<span class="string">"StrTest"</span>);
    Log.e(TAG, <span class="string">"onRestoreInstanceState+IntTest="</span>+IntTest+<span class="string">"+StrTest="</span>+StrTest);
}
</code></pre><p>需要注意的是，这两个method都是非生命周期method(区别于onCreate等)。这两个method只有在由android framework kill一个Activity(内存不足，用户直接按home键等等)才会触发，你可以在此存储一些数据，这样就可能在用户下次进入时恢复到之前的状态。而当用户正常退出一个Activity时(例如：按下back键)则不会触发这两个method。</p>
<pre><code>既然这两个<span class="keyword">method</span>你不一定会被触发，那么我们来测试一下，它们在什么情况下会被触发呢？
</code></pre><p>首先是onSaveInstanceState(Bundle savedInstanceState):</p>
<pre><code>按照文档解释实说当activity容易被销毁时会触发该<span class="keyword">method</span>，也就是该activity处于栈顶的时候。
</code></pre><p>我目前只意识到了以下几种情况会触发，如果大家有什么发现，欢迎交流补充，谢谢:<br>1.进入Activity后按下home键;<br>2.进入Activity后按下电源键;<br>3.在当前Activity下选择进入其他app，这个实现不太一样，了如我的MX3时上拉进入其它app，有的android机器则是长按home键;<br>4.横竖屏幕切换(Activity会被销毁，并restart)；<br>5.当前Activity失去焦点(被其他Activity覆盖)</p>
<p>截图如下:</p>
<p><img src="http://cl.ly/image/0Y3x2l3D0X2t/backHomeToOnSaveInstanceState.png" alt="Alt text"></p>
<p>接下来我们看看onRestoreInstanceState(Bundle savedInstanceState) method，这个方法只有在当前Activity确实被销毁了的情况下才会调用。如果是“有可能被销毁则不会被调用”。<br>因为这个比较难以观测，所以只给出横竖屏切换时的结果(横竖屏切换时Activity会被destroy并重新onCreate):<br>请看打印出来的倒数第二行，另外注意：onRestoreInstanceState()在onStart() 和 onPostCreate(Bundle)之间调用。可以自行打印看下。</p>
<p><img src="http://cl.ly/image/0n0S1j1m1d0j/onSaveInstanceState.png" alt="Alt text"></p>
<p>总结：<br>一般情况下推荐onSaveInstanceState()用于保存一些临时性的状态，一边用户再次返回时保留之前状态，留下很好的用户体验;而数据的持久化存储则应该在onPause() 方法中完成。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/11/30/android-saveinstancestate/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/11/30/android-saveinstancestate/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/11/30/android-saveinstancestate/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
      <time datetime="2014-11-27T08:13:34.000Z"><a href="/2014/11/27/android-view-详解/">周四, 11月 27 2014, 4:13:34 下午</a></time>

  
    <h1 class="title"><a href="/2014/11/27/android-view-详解/">android View 详解</a></h1>
  



  
  <div class="tags">
  	<i class="fa fa-tag"></i>
    <a href="/tags/android/">android</a>
  </div>

<div class="clear"></div>
      
    </header>
    <div class="entry">
      
        <p>android.View.View(即View)类是以矩形的方式显示在屏幕上，View是用户界面控件的基础。View的继承层次关系如下图：</p>
<p><img src="http://cl.ly/image/14202e2K001x/ViewClassOverView.png" alt="Alt text"></p>
<p>可以看到所有的界面控件都是View的子类。简单证实一下，每当你用findViewByIds(R.id.xx)时总要将其强转，因为该方法返回的是一个View实例，有木有!!!其中不得不提View的subClass ViewGroup。Android系统中的所有UI类都是建立在View和ViewGroup这两个类的基础上的。所有View的子类成为”Widget”，所有ViewGroup的子类成为”Layout”。View和ViewGroup之间采用了组合设计模式，可以使得“部分-整体”同等对待。ViewGroup作为布局容器类的最上层，布局容器里面又可以有View和ViewGroup。通过这种方式，我们获得了UI界面的组合方式。</p>
<p>ViewGroup的子类用不同的方式来管理容器中View控件的摆放位置以及显示方式；但是，对于view控件具体摆放到什么位置，以及大小等属性则需要每个布局类的内部类LayoutParams来进行处理，该类是ViewGroup的内部类，有该类的子类具体实现LayoutParams类。</p>
<p>可以看到android中所有的UI控件都是View的子类，所以你可以通过继承View类来实现自定义控件，例如之前博客中提到的圆形进度条就是一个例子。注意。此时你需要重载View的构造函数。View的构造函数有三个，但常用的是第一个和第二个，比较简单，有需要的可以查下文档。</p>
<p>一.而动态创建View和ViewGroup一般有以下2种方式可以实现。</p>
<p>1.每创建一个UI控件就添加到布局中，但是这种方式有个缺点，当你要动态添加的按钮过多时，就会显得过于麻烦。</p>
<p>  ViewParent viewParent = this.findViewById(R.id.text1).getParent();</p>
<p>   RelativeLayout relativeLayout = (RelativeLayout) viewParent;</p>
<p>   Button button = new Button(this);</p>
<p>   button.setText(“Fuck”);</p>
<p>   relativeLayout.addView(button,300,200);button,100,100);</p>
<p> 2.从一个XML文件中创建控件，再添加到布局中。</p>
<p>   LayoutInflater layoutInflater = this.getLayoutInflater();</p>
<p>   layoutInflater.inflate(R.layout.mybviewlayout,<br>                (ViewGroup)this.findViewById(R.layout.activity_main));</p>
<p>在第二句代码中关联了一个布局文件mybviewlayout.xml,在这里使用inflate方法将这个布局文件装载到内存中后被转化为View对象，，然后将这个View对象添加到activity_main.xml布局文件中。</p>
<p>二.常用布局</p>
<p>1.LinearLayout</p>
<p>相信大家对LinearLayout一定不会陌生吧，这里有一点需要注意：Linearlayout  不允许精准的控制它子view的关系，子view只能简单的一个接一个排成行。更好的方法是使用relativelayout.</p>
<p>2.RelativeLayout</p>
<p>该布局下我们可以非常灵活的来控制UI控件的摆放位置，在现实生活中我们最常用的应该是就是RelativeLayout与LinearLayout的结合使用了吧。这里就需要注意一下view的各种layout_XXX,margin_XX,等属性的使用了，他会帮你定制非常灵活的布局文件。我会在文章末尾附上。</p>
<p>3.TableLayout</p>
<p>TableLayout是用表格来进行UI界面的布局，个人感觉不太常用，使用的标签是<tablelayout>，而且TableLayout的属性是垂直排列，若想水平排列则应该使用TableRow。其他就不过多介绍了。</tablelayout></p>
<p>4.FrameLayout和AbsoluteLayout</p>
<p>FrameLayout和AbsoluteLayout分别是框架布局和绝对布局。frameLayout中UI控件默认显示在屏幕左上角，我记得Web浏览器中也是这样的，可用于图片扩散展示之类的。而AbsoluteLayout的用途相比看看名称就知道了，就我个人而言，目前并未使用到。</p>
<p>最后，就附上一些常用属性的说明吧，希望对大家有用。</p>
<p>android:alpha<br>关联方法: setAlpha(float)<br>属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</p>
<p>android:background<br>关联方法: setBackgroundResource(int)<br>属性说明: 视图背景</p>
<p>android:clickable<br>关联方法: setClickable(boolean)<br>属性说明: 视图是否可点击</p>
<p>android:contentDescription<br>关联方法: setContentDescription(CharSequence)<br>属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</p>
<p>android:drawingCacheQuality<br>关联方法: setDrawingCacheQuality(int)<br>属性说明: “设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存”</p>
<p>android:duplicateParentState<br>关联方法:<br>属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</p>
<p>android:fadeScrollbars<br>关联方法: setScrollbarFadingEnabled(boolean)<br>属性说明: 定义在ScrollBar没有使用时，是否褪色。</p>
<p>android:fadingEdgeLength<br>关联方法: getVerticalFadingEdgeLength()<br>属性说明: 设置边框渐变的长度。</p>
<p>android:filterTouchesWhenObscured<br>关联方法: setFilterTouchesWhenObscured(boolean)<br>属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</p>
<p>android:fitsSystemWindows<br>关联方法: setFitsSystemWindows(boolean)<br>属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</p>
<p>android:focusable<br>关联方法: setFocusable(boolean)<br>属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。</p>
<p>android:focusableInTouchMode<br>关联方法: setFocusableInTouchMode(boolean)<br>属性说明: 设置在Touch模式下View是否能取得焦点。</p>
<p>android:hapticFeedbackEnabled<br>关联方法: setHapticFeedbackEnabled(boolean)<br>属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</p>
<p>android:id<br>关联方法: setId(int)<br>属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.findViewById() 或Activity.findViewById()根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</p>
<p>android:importantForAccessibility<br>关联方法: setImportantForAccessibility(int)<br>属性说明: 设置可达性的重要性</p>
<p>android:isScrollContainer<br>关联方法: setScrollContainer(boolean)<br>属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</p>
<p>android:keepScreenOn<br>关联方法: setKeepScreenOn(boolean)<br>属性说明: 视图在可见的情况下是否保持唤醒状态。</p>
<p>android:layerType<br>关联方法: setLayerType(int,Paint)<br>属性说明: “设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。”</p>
<p>android:layoutDirection<br>关联方法: setLayoutDirection(int)<br>属性说明: 定义布局图纸的方向</p>
<p>android:longClickable<br>关联方法: setLongClickable(boolean)<br>属性说明: 是否响应长点击事件</p>
<p>android:minHeight<br>关联方法: setMinimumHeight(int)<br>属性说明: 设置视图最小高度</p>
<p>android:minWidth<br>关联方法: setMinimumWidth(int)<br>属性说明: 设置视图最小宽度</p>
<p>android:nextFocusDown<br>关联方法: setNextFocusDownId(int)<br>属性说明: 向下移动焦点时，下一个获取焦点的view的id</p>
<p>android:nextFocusForward<br>关联方法: setNextFocusForwardId(int)<br>属性说明: 下一个获取焦点的view的id</p>
<p>android:nextFocusLeft<br>关联方法: setNextFocusLeftId(int)<br>属性说明: 向左移动焦点时，下一个获取焦点的view的id</p>
<p>android:nextFocusRight<br>关联方法: setNextFocusRightId(int)<br>属性说明: 向右移动焦点时，下一个获取焦点的view的id</p>
<p>android:nextFocusUp<br>关联方法: setNextFocusUpId(int)<br>属性说明: 向上移动焦点时，下一个获取焦点的view的id</p>
<p>android:onClick<br>关联方法:<br>属性说明: 点击时，要调用的方法的名称。</p>
<p>android:padding<br>关联方法: setPaddingRelative(int,int,int,int)<br>属性说明: 设置上下左右的边距</p>
<p>android:paddingBottom<br>关联方法: setPaddingRelative(int,int,int,int)<br>属性说明: 下边距</p>
<p>android:paddingEnd<br>关联方法: setPaddingRelative(int,int,int,int)<br>属性说明: 与android:paddingRight相同</p>
<p>android:paddingLeft<br>关联方法: setPadding(int,int,int,int)<br>属性说明: 左边距</p>
<p>android:paddingRight<br>关联方法: setPadding(int,int,int,int)<br>属性说明: 右边距</p>
<p>android:paddingStart<br>关联方法: setPaddingRelative(int,int,int,int)<br>属性说明: android:paddingLeft相同</p>
<p>android:paddingTop<br>关联方法: setPaddingRelative(int,int,int,int)<br>属性说明: 上边距</p>
<p>android:requiresFadingEdge<br>关联方法: setVerticalFadingEdgeEnabled(boolean)<br>属性说明: 定义滚动时边缘是否褪色</p>
<p>android:rotation<br>关联方法: setRotation(float)<br>属性说明: 旋转度数</p>
<p>android:rotationX<br>关联方法: setRotationX(float)<br>属性说明: 水平旋转度数</p>
<p>android:rotationY<br>关联方法: setRotationY(float)<br>属性说明: 竖直旋转度数</p>
<p>android:saveEnabled<br>关联方法: setSaveEnabled(boolean)<br>属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</p>
<p>android:scaleX<br>关联方法: setScaleX(float)<br>属性说明: 水平方向缩放比例</p>
<p>android:scaleY<br>关联方法: setScaleY(float)<br>属性说明: 竖直方向缩放比例</p>
<p>android:scrollX<br>关联方法:<br>属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</p>
<p>android:scrollY<br>关联方法:<br>属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</p>
<p>android:scrollbarAlwaysDrawHorizontalTrack<br>关联方法:<br>属性说明: 是否总是绘制水平滚动条的滚动轨道</p>
<p>android:scrollbarAlwaysDrawVerticalTrack<br>关联方法:<br>属性说明: 是否总是绘制竖直滚动条的滚动轨道</p>
<p>android:scrollbarDefaultDelayBeforeFade<br>关联方法: setScrollBarDefaultDelayBeforeFade(int)<br>属性说明: 滚动条在n毫秒后开始淡出。</p>
<p>android:scrollbarFadeDuration<br>关联方法: setScrollBarFadeDuration(int)<br>属性说明: 滚动条用多长时间淡出完毕。</p>
<p>android:scrollbarSize<br>关联方法: setScrollBarSize(int)<br>属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</p>
<p>android:scrollbarStyle<br>关联方法: setScrollBarStyle(int)<br>属性说明: “滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。”</p>
<p>android:scrollbarThumbHorizontal<br>关联方法:<br>属性说明: 水平滚动块的drawable对象</p>
<p>android:scrollbarThumbVertical<br>关联方法:<br>属性说明: 竖直滚动块的drawable对象</p>
<p>android:scrollbarTrackHorizontal<br>关联方法:<br>属性说明: 水平滚动条滚动轨道的drawable对象</p>
<p>android:scrollbarTrackVertical<br>关联方法:<br>属性说明: 竖直滚动条滚动轨道的drawable对象</p>
<p>android:scrollbars<br>关联方法:<br>属性说明: “设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条”</p>
<p>android:soundEffectsEnabled<br>关联方法: setSoundEffectsEnabled(boolean)<br>属性说明: 点击或触摸该view时，是否需要有声音效果</p>
<p>android:tag<br>关联方法:<br>属性说明: string标识。类似id，id是整数标识。</p>
<p>android:textAlignment<br>关联方法: setTextAlignment(int)<br>属性说明: 设置文本的显示方式。</p>
<p>android:textDirection<br>关联方法: setTextDirection(int)<br>属性说明: 设置文本的显示方向。</p>
<p>android:transformPivotX<br>关联方法: setPivotX(float)<br>属性说明: 水平方向偏转量</p>
<p>android:transformPivotY<br>关联方法: setPivotY(float)<br>属性说明: 竖直方向偏转量</p>
<p>android:translationX<br>关联方法: setTranslationX(float)<br>属性说明: 水平方向的移动距离</p>
<p>android:translationY<br>关联方法: setTranslationY(float)<br>属性说明: 竖直方向的移动距离</p>
<p>android:visibility<br>关联方法: setVisibility(int)<br>属性说明: “view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见”</p>
<p>TextView属性说明</p>
<p>下面对TextView的属性进行说明<br>android:autoLink<br>关联方法: setAutoLinkMask(int)<br>属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)</p>
<p>android:autoText<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</p>
<p>android:bufferType<br>关联方法: setText(CharSequence,TextView.BufferType)<br>属性说明: 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</p>
<p>android:capitalize<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</p>
<p>android:cursorVisible<br>关联方法: setCursorVisible(boolean)<br>属性说明: 设定光标为显示/隐藏，默认显示。</p>
<p>android:digits<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()”</p>
<p>android:drawableBottom<br>关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</p>
<p>android:drawableEnd<br>关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。</p>
<p>android:drawableLeft<br>关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在text的左边输出一个drawable。</p>
<p>android:drawablePadding<br>关联方法: setCompoundDrawablePadding(int)<br>属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</p>
<p>android:drawableRight<br>关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在text的右边输出一个drawable。</p>
<p>android:drawableStart<br>关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。</p>
<p>android:drawableTop<br>关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)<br>属性说明: 在text的正上方输出一个drawable。</p>
<p>android:editable<br>关联方法:<br>属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</p>
<p>android:editorExtras<br>关联方法: setInputExtras(int)<br>属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</p>
<p>android:ellipsize<br>关联方法: setEllipsize(TextUtils.TruncateAt)<br>属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)</p>
<p>android:ems<br>关联方法: setEms(int)<br>属性说明: 设置TextView的宽度为N个字符的宽度。</p>
<p>android:fontFamily<br>关联方法: setTypeface(Typeface)<br>属性说明: 文本的字形体系。</p>
<p>android:freezesText<br>关联方法: setFreezesText(boolean)<br>属性说明: 设置保存文本的内容以及光标的位置。</p>
<p>android:gravity<br>关联方法: setGravity(int)<br>属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</p>
<p>android:height<br>关联方法: setHeight(int)<br>属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)</p>
<p>android:hint<br>关联方法: setHint(int)<br>属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</p>
<p>android:imeActionId<br>关联方法: setImeActionLabel(CharSequence,int)<br>属性说明: 设置IME动作ID。</p>
<p>android:imeActionLabel<br>关联方法: setImeActionLabel(CharSequence,int)<br>属性说明: 设置IME动作标签。在EditView再做说明。</p>
<p>android:imeOptions<br>关联方法: setImeOptions(int)<br>属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</p>
<p>android:includeFontPadding<br>关联方法: setIncludeFontPadding(boolean)<br>属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。</p>
<p>android:inputMethod<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</p>
<p>android:inputType<br>关联方法: setRawInputType(int)<br>属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</p>
<p>android:lineSpacingExtra<br>关联方法: setLineSpacing(float,float)<br>属性说明: 设置行间距。</p>
<p>android:lineSpacingMultiplier<br>关联方法: setLineSpacing(float,float)<br>属性说明: 设置行间距的倍数。如”1.2”</p>
<p>android:lines<br>关联方法: setLines(int)<br>属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</p>
<p>android:linksClickable<br>关联方法: setLinksClickable(boolean)<br>属性说明: 设置链接是否点击连接，即使设置了autoLink。</p>
<p>android:marqueeRepeatLimit<br>关联方法: setMarqueeRepeatLimit(int)<br>属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</p>
<p>android:maxEms<br>关联方法: setMaxEms(int)<br>属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</p>
<p>android:maxHeight<br>关联方法: setMaxHeight(int)<br>属性说明: 设置文本区域的最大高度</p>
<p>android:maxLength<br>关联方法: setFilters(InputFilter)<br>属性说明: 限制显示的文本长度，超出部分不显示。</p>
<p>android:maxLines<br>关联方法: setMaxLines(int)<br>属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</p>
<p>android:maxWidth<br>关联方法: setMaxWidth(int)<br>属性说明: 设置文本区域的最大宽度</p>
<p>android:minEms<br>关联方法: setMinEms(int)<br>属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</p>
<p>android:minHeight<br>关联方法: setMinHeight(int)<br>属性说明: 设置文本区域的最小高度</p>
<p>android:minLines<br>关联方法: setMinLines(int)<br>属性说明: 设置文本的最小行数，与lines类似。</p>
<p>android:minWidth<br>关联方法: setMinWidth(int)<br>属性说明: 设置文本区域的最小宽度</p>
<p>android:numeric<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</p>
<p>android:password<br>关联方法: setTransformationMethod(TransformationMethod)<br>属性说明: 以小点”.”显示文本</p>
<p>android:phoneNumber<br>关联方法: setKeyListener(KeyListener)<br>属性说明: 设置为电话号码的输入方式。</p>
<p>android:privateImeOptions<br>关联方法: setPrivateImeOptions(String)<br>属性说明: 设置输入法选项，在EditText中才有作用。</p>
<p>android:scrollHorizontally<br>关联方法: setHorizontallyScrolling(boolean)<br>属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</p>
<p>android:selectAllOnFocus<br>关联方法: setSelectAllOnFocus(boolean)<br>属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</p>
<p>android:shadowColor<br>关联方法: setShadowLayer(float,float,float,int)<br>属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</p>
<p>android:shadowDx<br>关联方法: setShadowLayer(float,float,float,int)<br>属性说明: 设置阴影横向坐标开始位置。</p>
<p>android:shadowDy<br>关联方法: setShadowLayer(float,float,float,int)<br>属性说明: 设置阴影纵向坐标开始位置。</p>
<p>android:shadowRadius<br>关联方法: setShadowLayer(float,float,float,int)<br>属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</p>
<p>android:singleLine<br>关联方法: setTransformationMethod(TransformationMethod)<br>属性说明: 设置单行显示。如果和layout<em>width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test</em> singleLine “ android:singleLine=”true” android:layout_width=”20dp”将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</p>
<p>android:text<br>关联方法: setText(CharSequence,TextView.BufferType)<br>属性说明: 设置显示文本.</p>
<p>android:textAllCaps<br>关联方法: setAllCaps(boolean)<br>属性说明: 设置文本全为大写。值为”true”或”false”。</p>
<p>android:textAppearance<br>关联方法:<br>属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse</p>
<p>android:textColor<br>关联方法: setTextColor(int)<br>属性说明: 设置文本颜色</p>
<p>android:textColorHighlight<br>关联方法: setHighlightColor(int)<br>属性说明: 被选中文字的底色，默认为蓝色</p>
<p>android:textColorHint<br>关联方法: setHintTextColor(int)<br>属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</p>
<p>android:textColorLink<br>关联方法: setLinkTextColor(int)<br>属性说明: 文字链接的颜色.</p>
<p>android:textIsSelectable<br>关联方法: isTextSelectable()<br>属性说明: 设置非编辑文本可否被选择。值为”true”或”false”。</p>
<p>android:textScaleX<br>关联方法: setTextScaleX(float)<br>属性说明: 设置文字之间间隔，默认为1.0f。</p>
<p>android:textSize<br>关联方法: setTextSize(int,float)<br>属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</p>
<p>android:textStyle<br>关联方法: setTypeface(Typeface)<br>属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</p>
<p>android:typeface<br>关联方法: setTypeface(Typeface)<br>属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]</p>
<p>android:width<br>关联方法: setWidth(int)<br>属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</p>
<p>android:fadingEdgeLength</p>
<p>设置淡入淡出边缘的长度，可以接受大小值的单位是：px、dp、sp、in、mm，也可以参考大小值资源</p>
<p>android:fitsSystemWindows</p>
<p>是否适合系统窗体，取值为true或false。该属性只对不是子组件的组件有效</p>
<p>android:focusable</p>
<p>是否可以获取焦点，取值true或false</p>
<p>android:focusableInTouchMode</p>
<p>是否可以在触摸模式下获取焦点，true或false</p>
<p>android:hapticFeedbackEnabled</p>
<p>是否允许触摸反馈效果，true或false</p>
<p>android:id</p>
<p>提供该组件的标识名，可以借助Activity或View实例的findViewById方法通过id获取对应的组件实例对象，其属性值的形式为：android:id=”@+id/id<id>”</id></p>
<p>android:isScrollContainer</p>
<p>设置该组件是否设置为滚动条容器，true或false</p>
<p>android:keepScreenOn</p>
<p>控制该组件在显示的时候保持在屏幕显示，true或false</p>
<p>android:longClickable</p>
<p>是否响应长时间点击事件，true或false</p>
<p>android:minHeight</p>
<p>组件的最小高度，取值同android:fadingEdgeLength</p>
<p>android:minWidth</p>
<p>组件的最小宽度，取值同android:fadingEdgeLength</p>
<p>android:nextFocusDown</p>
<p>设置下一个向下获取焦点的组件，取值为id</p>
<p>android:nextFocusLeft</p>
<p>设置下一个向左获取焦点的组件，取值为id</p>
<p>android:nextFocusRight</p>
<p>设置下一个向右获取焦点的组件，取值为id</p>
<p>android:nextFocusUp</p>
<p>设置下一个向上获取焦点的组件，取值为id</p>
<p>android:padding</p>
<p>设置上、下、左、右4个边缘的填充距离，必须是一个大小值，取值同android:fadingEdgeLength</p>
<p>android:paddingBottom</p>
<p>设置下端边缘的填充距离，取值同android:padding</p>
<p>android:paddingLeft</p>
<p>设置左端边缘的填充距离，取值同android:padding</p>
<p>android:paddingRight</p>
<p>设置右端边缘的填充距离，取值同android:padding</p>
<p>android:paddingTop</p>
<p>设置上端边缘的填充距离，取值同android:padding</p>
<p>android:saveEnabled</p>
<p>是否允许保存状态，取值为true或false</p>
<p>android:scrollX</p>
<p>设置垂直滚动条的位移量，必须是一个大小值，取值同android:padding</p>
<p>android:scrollY</p>
<p>设置水平滚动条的位移量，必须是一个大小值，取值同android:padding</p>
<p>android:scrollbarAlwaysDrawHorizontalTrack</p>
<p>是否总是设置水平滚动条滑块，true或false</p>
<p>android:scrollbarAlwaysDrawVerticalTrack</p>
<p>是否总是设置垂直滚动条滑块，true或false</p>
<p>android:scrollbarSize</p>
<p>设置垂直滚动条的宽度和水平滚动条的长度，必须是一个大小值，取值同android:padding</p>
<p>android:scrollbarStyle</p>
<p>设置滚动条的样式，取值为下列之一：</p>
<p>insideOverlay在填充区域内，覆盖形式</p>
<p>insideInset在填充区域内，插进形式（凹进）</p>
<p>outsideOverly在绑定组件边缘，覆盖形式</p>
<p>outsideInset在绑定组件边缘，插进形似</p>
<p>android:scrollbarThumbHorizontal</p>
<p>设置水平滚动条按钮的绘制资源，必须引用可绘制资源</p>
<p>android:scrollbarThumbVertical</p>
<p>设置垂直滚动条按钮的绘制资源，必须引用可绘制资源</p>
<p>android:scrollbarTrackHorizontal</p>
<p>设置水平滚动条轨道的绘制资源，必须引用可绘制资源</p>
<p>android:scrollbarTrackVertical</p>
<p>设置水平滚动条轨道的绘制资源，必须引用可绘制资源</p>
<p>android:scrollbars</p>
<p>设置滚动显示，可以为一下一个或多个值：</p>
<p>none不显示滚动条</p>
<p>horizontal只显示水平滚动条</p>
<p>vertical只显示垂直滚动条</p>
<p>android:soundEffectsEnabled</p>
<p>是否允许音效，取值为true或false</p>
<p>android:tag</p>
<p>设置标记内容，可以通过View类实例的getTag方法获取该组件的标记内容，或者使用findViewByTag通过标记来查找相应的子组件</p>
<p>android:visibility</p>
<p>设置初始化可见状态，取值为以下之一：</p>
<p>visible可见（默认值）</p>
<p>invisible不可见（其所占空间将留出）</p>
<p>gone完全不可见（其所占空间都不会留出）</p>
<p>线性布局LinearLayout组件属性列表</p>
<p>属性</p>
<p>说明</p>
<p>android:baselineAligned</p>
<p>基线对齐</p>
<p>android:baselineAlignedChildIndex</p>
<p>以指定子组件作为基线对齐</p>
<p>android:gravity</p>
<p>指定该物体放入其容器的重心位置，取值为下列之一：</p>
<p>top上方，物体大小不变</p>
<p>bottom下方，物体大小不变</p>
<p>left左方，物体大小不变</p>
<p>right右方，物体大小不变</p>
<p>center_vertical垂直方向的中间，物体大小不变</p>
<p>fill_vertical填满垂直方向，自动进行大小调整</p>
<p>center_horizontal水平方向的中间，大小不变</p>
<p>fill_horizontal填满水平方向，自动进行大小调整</p>
<p>center居中（既是水平也是垂直方向的中间）</p>
<p>fill填满整个容器</p>
<p>clip_vertical</p>
<p>clip_horizontal</p>
<p>android:orientation</p>
<p>布局方向，取值为下列之一：</p>
<p>horizontal水平的</p>
<p>vertical垂直的（默认值）</p>
<p>android:weightSum</p>
<p>组件的比重和</p>
<p>线性布局参数LinearLayout_Layout</p>
<p>属性</p>
<p>说明</p>
<p>android:layout_gravity</p>
<p>当前子组件的心位置</p>
<p>android:layout_height</p>
<p>当前子组件的高度</p>
<p>android:layout_weight</p>
<p>当前子组件的空间比重，取值为浮点数</p>
<p>android:layout_width</p>
<p>当前子组件的宽度</p>
<p>相对布局RalativeLayout</p>
<p>属性</p>
<p>说明</p>
<p>android:gravity</p>
<p>设置添加组件的重心</p>
<p>android:ignoreGravity</p>
<p>忽略布局重心的影响</p>
<p>相对布局参数RalativeLayout_Layout</p>
<p>属性</p>
<p>说明</p>
<p>android:layout_above</p>
<p>将当前组件的下边缘放置于参照组件之上，该属性为参照组件的ID</p>
<p>android:layout_alignBaseline</p>
<p>当前组件与参照组件的基线对齐，该属性为参照组件的ID</p>
<p>android:layout_alignBottom</p>
<p>当前组件与参照组件的下边界对齐，该属性为参照组件的ID</p>
<p>android:layout_alignLeft</p>
<p>当前组件与参照组件的左边界对齐，该属性为参照组件的ID</p>
<p>android:layout_alignParenBottom</p>
<p>当前组件与父组件的下边界对齐，true或false</p>
<p>android:layout_alignParentLeft</p>
<p>当前组件与父组件的左边界对齐，true或false</p>
<p>android:layout_alignParentRight</p>
<p>当前组件与父组件的右边界对齐，true或false</p>
<p>android:layout_alignParentTop</p>
<p>当前组件与父组件的上边界对齐，true或false</p>
<p>android:layout_alignRight</p>
<p>当前组件与参照组件的右边界对齐，该属性为参照组件的ID</p>
<p>android:layout_alignTop</p>
<p>当前组件与参照组件的上边界对齐，该属性为参照组件的ID</p>
<p>android:layout_alignWithParentIfMissing</p>
<p>true或false</p>
<p>android:layout_below</p>
<p>将当前组件的上边缘放置于参照组件之下，该属性为参照组件的ID</p>
<p>android:layout_centerHorizontal</p>
<p>当前组件放置到父组件的水平居中的位置</p>
<p>android:layout_centerInParent</p>
<p>当前组件放置到父组件的重心位置</p>
<p>android:layout_centerVertical</p>
<p>当前组件放置到父组件垂直居中的位置</p>
<p>android:layout_toLeftOf</p>
<p>将当前组件的右边缘放置于参照组件之下，该属性为参照组件的ID</p>
<p>android:layout_toRightOf</p>
<p>将当前组件的左边缘放置于参照组件之下，该属性为参照组件的ID</p>
<p>绝对布局参数AbsoluteLayout_Layout</p>
<p>属性</p>
<p>说明</p>
<p>android:layout_x</p>
<p>当前组件的x坐标位置（从左到右方向）</p>
<p>android:layout_y</p>
<p>当前组件的y坐标位置（从上到下方向）</p>
<p>框布局FrameLayout</p>
<p>属性</p>
<p>说明</p>
<p>android:foreground</p>
<p>前置图片</p>
<p>android:foregroundGravity</p>
<p>前置图片重心</p>
<p>android:measureAllChildren</p>
<p>在切换显示时是否侧重所有子组件的大小</p>
<p>android:layout_gravity</p>
<p>添加组件的重心</p>
<p>框布局参数FrameLayout_Layout</p>
<p>属性</p>
<p>说明</p>
<p>android:layout_gravity</p>
<p>当前子组件所添加的重心位置</p>
<p>表格布局TableLayout</p>
<p>属性</p>
<p>说明</p>
<p>android:collapseColumns</p>
<p>设置允许折叠的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</p>
<p>android:shrinkColumns</p>
<p>设置允许收缩的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</p>
<p>android:stretchColumns</p>
<p>设置允许伸展的列编号，列编号基于0，属性值可以是单个或多个列编号，编号与编号直接用逗号”,”分隔</p>
<p>表格行的单元TableRow_Cell</p>
<p>属性</p>
<p>说明</p>
<p>android:layout_column</p>
<p>设置该单元格的列编号（基于0）</p>
<p>android:layout_span</p>
<p>指明该单元格可以跨越的列数</p>
<p>抽象列表视图组件AbsListView</p>
<p>属性</p>
<p>说明</p>
<p>android:cacheColorHint</p>
<p>设置缓冲颜色</p>
<p>android:drawSelectorOnTop</p>
<p>是否将选择器绘制在备选条目上方，取值为true或false</p>
<p>android:fastScrollEnabled</p>
<p>允许快速滚动</p>
<p>android:listSelector</p>
<p>指示选择器的内容</p>
<p>android:scrollingCache</p>
<p>滚动时是否使用绘制缓冲，true或false</p>
<p>android:smoothScrollbar</p>
<p>平滑滚动条</p>
<p>android:stackFromBottom</p>
<p>从下方堆叠条目</p>
<p>android:textFilterEnbled</p>
<p>是否允许过滤</p>
<p>android:transcriptMode</p>
<p>设置抄本模式</p>
<p>列表视图组件ListView</p>
<p>属性</p>
<p>说明</p>
<p>android:choiceMode</p>
<p>选择模式</p>
<p>android:divider</p>
<p>分割线颜色或组件的参考</p>
<p>android:dividerHeight</p>
<p>分割线高度</p>
<p>android:entries</p>
<p>指定绑定到当前列表视图的一个数组资源</p>
<p>android:footerDividersEnabled</p>
<p>是否允许页脚分割线</p>
<p>android:headerDividersEnabled</p>
<p>是否允许页眉分割线</p>
<p>格子视图组件GridView</p>
<p>属性</p>
<p>说明</p>
<p>android:columnWidth</p>
<p>指定列宽</p>
<p>android:gravity</p>
<p>添加组件的重心位置</p>
<p>android:horizontalSpacing</p>
<p>水平空间</p>
<p>android:numColumns</p>
<p>指定列数</p>
<p>android:strechMode</p>
<p>伸展模式</p>
<p>android:verticalSpacing</p>
<p>垂直空间</p>
<p>画廊视图组件Gallery</p>
<p>属性</p>
<p>说明</p>
<p>android:animationDuration</p>
<p>动画持续时间</p>
<p>android:gravity</p>
<p>添加组件的重心位置</p>
<p>android:spacing</p>
<p>间隔空间</p>
<p>android:unselectedAlpha</p>
<p>非选择条目的透明度</p>
<p>文本组件TextView</p>
<p>属性</p>
<p>说明</p>
<p>android:autoLink</p>
<p>是否自动链接（内容是网址或是电子邮件时）</p>
<p>android:autoText</p>
<p>自动更新拼音错误</p>
<p>android:bufferType</p>
<p>设置缓冲区类型</p>
<p>android:capitalize</p>
<p>自动大写</p>
<p>android:cursorVisible</p>
<p>光标是否可见，true或false</p>
<p>android:digits</p>
<p>所接受的数字字符</p>
<p>android:drawableBottom</p>
<p>在文本下方绘制</p>
<p>android:drawableLeft</p>
<p>在文本左方绘制</p>
<p>android: drawablePadding</p>
<p>绘制填充区</p>
<p>android: drawableRight</p>
<p>在文本右方绘制</p>
<p>android: drawableTop</p>
<p>在文本上方绘制</p>
<p>android:editable</p>
<p>是否可编辑，true或false</p>
<p>android:editorExtras</p>
<p>android:ellipsize</p>
<p>当内容过长时会自动打断单词内容</p>
<p>android:ems</p>
<p>android:enabled</p>
<p>是否可用，true或false</p>
<p>android:freezesText</p>
<p>是否冻结文本</p>
<p>android:gravity</p>
<p>指明文本的重心位置</p>
<p>android:height</p>
<p>高度值</p>
<p>android:hint</p>
<p>指示内容</p>
<p>android:imeActionId</p>
<p>android:imeActionLabel</p>
<p>android:imeOptions</p>
<p>输入法选项</p>
<p>android:includeFontPadding</p>
<p>android:inputMethod</p>
<p>指定输入法</p>
<p>android:inputType</p>
<p>输入类型，取值为下列之一：</p>
<p>none</p>
<p>text普通文本</p>
<p>textCapCharacters大写字符</p>
<p>textCapWords单词首字母大写</p>
<p>textCapSentences句子首字母大写</p>
<p>textAutoCorret自动更正</p>
<p>textAutoComplete自动完成</p>
<p>textMultiLine多行内容</p>
<p>textUri，Uri</p>
<p>textEmailAddress电子邮件地址</p>
<p>textEmailSubject电子邮件主题</p>
<p>textShortMessage短消息</p>
<p>textLongMessage长消息</p>
<p>textPersonName个人姓名</p>
<p>textPostalAddress邮政地址</p>
<p>textPassword密码</p>
<p>textVIsiblePassword可见的密码</p>
<p>textWebEditText网页格式</p>
<p>textFilter过滤字符串</p>
<p>textPhonetic语言发音</p>
<p>number数字</p>
<p>numberSigned有符号数字</p>
<p>numberDecimal十进制数字</p>
<p>phone电话号码</p>
<p>datetime日期时间</p>
<p>date日期</p>
<p>time时间</p>
<p>android:lineSpacingExtra</p>
<p>android:lineSpacingMultiplier</p>
<p>android:lines</p>
<p>设置文本行数</p>
<p>android:linksClickable</p>
<p>android:marqueeRepeatLimit</p>
<p>来回移动的动画次数</p>
<p>android:maxEms</p>
<p>android:maxHeight</p>
<p>物体的最大高度</p>
<p>android:maxLength</p>
<p>最大文本长度</p>
<p>android:maxLines</p>
<p>最大行数</p>
<p>android:minWidth</p>
<p>物体的最大宽度</p>
<p>android:minEms</p>
<p>android:minHeight</p>
<p>物体的最小高度</p>
<p>android:minLines</p>
<p>最小文本行数</p>
<p>android:minWidth</p>
<p>物体的最小宽度</p>
<p>android:numeric</p>
<p>是否使用数字输入方式</p>
<p>android:password</p>
<p>是否使用密码输入方式</p>
<p>android:phonenumber</p>
<p>是否使用电话号码输入方式</p>
<p>android:privateImeOptions</p>
<p>android:scrollHorizontally</p>
<p>android:selectAllOnFocus</p>
<p>android:shadowColor</p>
<p>文本阴影颜色</p>
<p>android:shadowDx</p>
<p>阴影的水平偏移</p>
<p>android:shadowDy</p>
<p>阴影的垂直偏移</p>
<p>android:shadowRadius</p>
<p>阴影的半径</p>
<p>android:singleLine</p>
<p>是否单行（不自动换行）</p>
<p>android:text</p>
<p>显示的文本内容</p>
<p>android:textApperance</p>
<p>基本字体颜色、字样、大小和样式</p>
<p>android:textColor</p>
<p>文本颜色</p>
<p>android: textColorHighlight</p>
<p>文本高亮颜色</p>
<p>android: textColorHint</p>
<p>文本提示颜色</p>
<p>android:textColorLink</p>
<p>文本链接颜色</p>
<p>android:textScaleX</p>
<p>文本缩放因数</p>
<p>android:textSize</p>
<p>文本大小</p>
<p>android:textStyle</p>
<p>文本样式，取值为下列之一：</p>
<p>bold粗体</p>
<p>italic斜体</p>
<p>bolditalic粗斜体</p>
<p>android:typeface</p>
<p>字样</p>
<p>android:width</p>
<p>物体的高度</p>
<p>自动完成文本框AutoCompleteTextView</p>
<p>属性</p>
<p>说明</p>
<p>android:completionHint</p>
<p>显示提示</p>
<p>android:completionHintView</p>
<p>提示视图</p>
<p>android:completionThreshold</p>
<p>设置开始提示的字符数</p>
<p>android:dropDownAnchor</p>
<p>下拉框链接视图</p>
<p>android:dropDownSelector</p>
<p>下拉框选择器</p>
<p>android:dropDownWIdth</p>
<p>下拉框宽度</p>
<p>图片视图ImageView</p>
<p>属性</p>
<p>说明</p>
<p>android:adjustViewBounds</p>
<p>是否调整视图范围</p>
<p>android:baselineAlignBottom</p>
<p>是否按照下端基线对齐</p>
<p>android:cropToPadding</p>
<p>是否按照填充进行裁剪</p>
<p>android:maxHeight</p>
<p>设置最大高度</p>
<p>android:maxWidth</p>
<p>设置最大宽度</p>
<p>android:scaleType</p>
<p>缩放类型，取值为下列之一：</p>
<p>matrix图片真实大小</p>
<p>fitXY适合图片大小</p>
<p>fitStart</p>
<p>fitCenter</p>
<p>fitEnd</p>
<p>center居中显示</p>
<p>centerCrop</p>
<p>centerInside</p>
<p>android:src</p>
<p>设置绘制用内容</p>
<p>android:tint</p>
<p>设置染色颜色值</p>
<p>android:layout_above=”@id/xxx”  —将控件置于给定ID控件之上<br>android:layout_below=”@id/xxx”  —将控件置于给定ID控件之下</p>
<p>android:layout_toLeftOf=”@id/xxx”  —将控件的右边缘和给定ID控件的左边缘对齐<br>android:layout_toRightOf=”@id/xxx”  —将控件的左边缘和给定ID控件的右边缘对齐</p>
<p>android:layout_alignLeft=”@id/xxx”  —将控件的左边缘和给定ID控件的左边缘对齐<br>android:layout_alignTop=”@id/xxx”  —将控件的上边缘和给定ID控件的上边缘对齐<br>android:layout_alignRight=”@id/xxx”  —将控件的右边缘和给定ID控件的右边缘对齐<br>android:layout_alignBottom=”@id/xxx”  —将控件的底边缘和给定ID控件的底边缘对齐<br>android:layout_alignParentLeft=”true”  —将控件的左边缘和父控件的左边缘对齐<br>android:layout_alignParentTop=”true”  —将控件的上边缘和父控件的上边缘对齐<br>android:layout_alignParentRight=”true”  —将控件的右边缘和父控件的右边缘对齐<br>android:layout_alignParentBottom=”true” —将控件的底边缘和父控件的底边缘对齐<br>android:layout_centerInParent=”true”  —将控件置于父控件的中心位置<br>android:layout_centerHorizontal=”true”  —将控件置于水平方向的中心位置<br>android:layout_centerVertical=”true”  —将控件置于垂直方向的中心位置</p>
<p>好吧，就这样吧，最近感觉甚是迷茫，就回头梳理一下过往吧。</p>

      
    </div>
    <footer>
      
        <div class="alignleft">
            <a href="/2014/11/27/android-view-详解/#more" class="more-link"><i class="fa fa-chevron-right"></i>Read More</a>
        </div>
        
        
          <div class="alignright"> 
            <a href="http://canglangwenyue.com/2014/11/27/android-view-详解/#comment" class="comment-link">
              <i class="fa fa-comments"></i><span class="ds-thread-count" data-thread-key="/2014/11/27/android-view-详解/">&nbsp;
              </span>
            </a>
          </div>
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页<i class="fa fa-long-arrow-right"></i></a>
  
  <div class="clearfix"></div>
</nav>

<script src="/js/jquery.anystretch.min.js" type="text/javascript"></script>
<script src="/js/cover.js" type="text/javascript"></script>

    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div>
  
  &copy; 2015 Wenyue
  
</div>
Powered by <a href="http://zespia.tw/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> and <a href="http://pages.github.com/" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>

<div class="clearfix"></div></footer>
  
<script src="/js/jquery.imagesloaded.min.js" type="text/javascript"></script>
<script src="/js/gallery.js" type="text/javascript"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.0/js/bootstrap.min.js" type="text/javascript"></script>




    <script type="text/javascript">
        (function(){

            $(window).scroll(function(){

                var scrollTop = $(window).scrollTop();
                if ( scrollTop >200 ){
                    $("#main-nav").removeClass('normal_mode').addClass('top_mode');
                } else{
                    $("#main-nav").removeClass('top_mode').addClass('normal_mode');
                }

            });

        })();
    </script>



  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
  (function($){
    $('.fancybox').fancybox({
      'titlePosition': 'inside'
    });
  })(jQuery);
  </script>



    
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"wenyue"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = 'http://static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



<script type="text/javascript">
  
  $(function(){

    $('.title').hover(
      function() {      
        $(this).stop().animate(
          {'marginLeft': '10px'}, 200
        );   
      }, 
      function() {       
        $(this).stop().animate({'marginLeft': '0px'}, 200);      
      
    });   

  });

</script>


</body>
</html>